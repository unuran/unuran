

User interface:

Structures:

struct unur_par parameter;  /* structure for (default) parameters for initializing generator */ 
struct unur_gen generator;  /* structure for generator object */

For every transformation method <tm> there exists:

/* get default parameters       */
struct unur_par *<tm>_new( ... args ... );

the generator can be started and used via:

/* initialize new generator     */
struct unur_gen *unur_init(struct unur_par *params);

/* sample from generator */
int    unur_sample_discr(struct unur_gen *generator);  /* discrete variates */
double unur_sample_cont (struct unur_gen *generator);  /* cont. variates    */

/* destroy generator object */
void unur_free(struct unur_gen *generator);

Notice, that unur_init() deallocates the memory where "params" points to.

You MUST NOT provide a pointer to an object on the stack!
You MUST NOT use the object returned by <tm>_new() after you have called unur_init()!

<tm>_new() and unur_init() return a NULL pointer in case of errors.

unur_sample_discr()  and unur_sample_cont()
always return 0 in case of error 
(e.g. because the user did not check whether unur_init() has returned a valid 
pointer to a generator object or a NULL pointer).

/******************************************************************************/

Here is small example that demonstrates how to use this library:

Assume you want to generate a discrete random variate with an arbitrary but
finite probability vector. Indexed search is a proper method for this job. 
Its name is DIS.

So we need the following routines:

Here is the C source:

/* example.c */

#include "unuran.h"  /* include library header */

#define SIZE 8       /* length of probability vector */   

int main()
{ 
  int x;

  struct unur_par *parameter;   /* pointer to parameter structure */
  struct unur_gen *generator;   /* pointer to generator object    */

  /* the probability vector (need not sum to 1 !) */
  double p[] = {1.,1.,0.75,0.56,0.43,0.35,0.05,0.78};

  /* Now let's start */ 

  /* get default parameters for new generator */
  parameter = dis_new(p,SIZE);
  if( parameter == NULL ) { fprintf(stderr,"error!"); exit(-1); }

  /* initialize generator */
  generator = unur_init(parameter);
  if( generator == NULL ) { fprintf(stderr,"error!"); exit(-1); }

  /* sample from distribution */
  x = unur_sample_discr(generator);

  /* free generator (when we do not need it any more) */
  unur_free(generator);

  /* end of program */
  exit(0);
}

/******************************************************************************/

There are some internal calls for programers of the library.

/****/

set and check magic cookies for parameter structure and generator object:

   COOKIE_SET  (*ptr, ck, rval);
   COOKIE_CHECK(*ptr, ck), rval);

ptr  is the pointer to the respective structure,
ck   is the magic cookie for this structure,
rval value that should be returned by routine in case of error.

implemented as macro.

This call has no effect unless the UNURAN_DEBUG is set.

/****/

check for NULL pointer:

   CHECK_NULL(ptr, rval);

ptr  pointer to be checked,
rval value that should be returned by routine in case of error.

implemented as macro.

This call has no effect unless the UNURAN_DEBUG is set.

/****/

To produce a warning or error message use

   unur_warning(char *genid, int errcode, char *str);

genid   points to an identifying string. Can be NULL.
errcode type of error
str     points to message

implemented as marco and subroutine.

The message is printed to stderr and/or a logfile
(depends on UNURAN_DEBUG).

This call has no effect unless the UNURAN_DEBUG is set.

/****/

Each generator object should have a unique identifier. 
You get such an identifier by this routine:

   void set_genid(*generator, char *gentype);

it produces a string of the form <gentype>.<number>,
where <gentype> is the string in the argument list,
and sets the pointer in the generator object to this address.

Since set_genid calls malloc(), you can free this memory space by

   void free_genid(*generator);

implemented as marcos.

set_genid() and free_genid() have no effect unless UNURAN_DEBUG is set.

/****/

To call a uniform random number generator always use

   urng(*generator);

for the case where the urng is not linked at compile time you MUST use

   urng_set_default(*parameter)

to set the pointer to the default urng in <tm>_new(), and

   void urng_copy_pointer(*parameter,*generator);

to copy the pointer to the urng provided in the parameter structure 
into the generator object.

implemented as marcos.

urng_set_default() and urng_copy_pointer() have no effect if the urng
is linked at compile time.

/****/
/****/
/****/





































