 
\input texinfo   @c -*-texinfo-*-

@c Dies ist das neue UNURAN -Einfuehrung  
@c Juli 2000 Janka & Tirler                
@c $Id$


@c %**start of header
@setfilename qstart.info
@settitle    UNURAN User Manual
@iftex
@afourpaper
@end iftex
@paragraphindent 0
@c %**end of header



@dircategory Scientific software
@direntry
* unuran-ref: (unuran-ref).  UNURAN -- Universal Non-Uniform Random number generator
@end direntry


@titlepage
@end titlepage


@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
@c
@c `Top' Node and Master Menu
@c


@ifnottex
@node Top,     Intro,  ,          (dir)     
@top
@c    node-name, next,          previous,  up
@end ifnottex     
Hier steht also Text in tex und auch sonst -- the top node summary
@menu
* Intro::         Introduction
* Methods::       How should the random numbers be created
* FAQ::           Frequently asked questions
* Reference::     Function Reference
* Distributions:: Distributions
* Internal::     Internal remarks
@end menu
@ifhtml
Table of @ref{Contents}
@end ifhtml

@node Intro
@chapter Introduction
@menu
* Overview:: Overview
* Install::   Installing the thing
* Start::    Getting Started
@end menu


@node Overview
@section Overview

@node Install
@section Install
@menu
* Now
@end menu


node Now
@subsection now
cvs update @*
@* 'make' in UNURAN to compile UNURAN
@* Makefile.am in /examples modify in regard to testprogram 
@* make in /examples

@node Start
@section Getting start
@*Beginning example
@*call the compiler with:
@*gcc -Wall  -L../src/methods  -L../src/distributions  -L../src/tests  -L../src/uniform -g -O2  -o test1  test1.o -lunuran_tests -lunuran_distributions -lunuran -luniform -lprng -lm

Code:

@smallexample
/* my first UNURAN program */ 

#include <unuran.h>
#include <unuran_distributions.h>
#include <unuran_tests.h>

int main()
@{
  double x;
  int    i;

  struct unur_distr *distr;  /* distribution */ 
  struct unur_par *par;      /* parameter */
  struct unur_gen *gen;      /* generator */
/* mache neues Verteilungsobjekt unur_distr_cont_new (methods.distr.c)   */
/*     setze pointer auf pdf und cdf  */
 
  /* make distr. object: truncated Gaussian */
  distr = unur_distr_normal(NULL,0);
  unur_distr_cont_set_domain(distr, -2.,2.);

  /* choose method and set parameters */
  par = unur_arou_new(distr);
  unur_arou_set_max_sqhratio(par,0.99);

  /* make generator object */
  gen = unur_init(par);

  /* sample */
  for (i=0;i<100;i++) @{
  x = unur_sample_cont(gen);
  printf("%f\n",x);
  @}
@} 
@end smallexample

First you have to include the libraries @code{unuran.h} and @code{unuran_distributions.h} with the commands:

@smallexample
#include <unuran.h>
#include <unuran_distributions.h> 
@end smallexample 
This headers provide all functions/features for generating random numbers.
Three structures 
@smallexample
struct unur_distr *distr;  /* distribution */ 
  struct unur_par *par;    /* parameter */
  struct unur_gen *gen;    /* generator */
@end smallexample
are necesssary to store the used parameters. It is not necessary to understand the structure in detail to get random numbers. 
@*
With
@smallexample
 distr = unur_distr_normal(NULL,0);
@end smallexample
we generate an distribution,
and with
@smallexample
 par = unur_arou_new(distr);
@end smallexample
we have genarate the parameters of the method 'arou'
Now its possible to change default parameters of the method with @code{
 unur_arou_set_max_sqhratio(par,0.99);}
@*

@smallexample
gen = unur_init(par)
@end smallexample
we generate an genarator objekt (and destroy the the objects distr.(?) and par)
which is necessary to genarate an non uniform random number with
@smallexample
 x = unur_sample_cont(gen);
@end smallexample

If you know the c.d.f you can genarate +random numbers in the following way
The important lines are in bold face.

@smallexample
/* my second UNURAN program test2.c */ 

#include <unuran.h>
#include <unuran_distributions.h>
#include <unuran_tests.h>
@b{
double trig (double x)
@{  return ( (x<0.) ? 0. : (x>1.) ?1. : x ); @}  
}
int main()
@{
  double x;
  int    i;

  struct unur_distr *distr,*distr1;  /* distribution */ 
  struct unur_par *par,*par1;      /* parameter */
  struct unur_gen *gen,*gen1;      /* generator */
 
  /* make distr. object: truncated Gaussian */
@b{  distr1 = unur_distr_cont_new();
  unur_distr_cont_set_cdf(distr1, trig );
}

  /* choose method and set parameters */
  par1 = unur_ninv_new(distr1);
 
  /* make generator object */
  gen1 = unur_init(par1);


  /* sample */
  for (i=0;i<100;i++) @{
  x = unur_sample_cont(gen1);
  printf("%f\n",x);
  @}
 


  /* destroy generator object */
  // unur_free(gen);
  unur_free(gen1);

  exit (0);
@}
@end smallexample

If want to change the parameters of a method:
The important lines are in bold face.

@smallexample

/* my second UNURAN program test2.c */ 

#include <unuran.h>
#include <unuran_distributions.h>
#include <unuran_tests.h>

double trig (double x)
@{  return ( (x<0.) ? 0. : (x>1.) ? 1. : x ); @}  
@b{ double pdftrig (double x)
@{  return ( (0.<x || x<1.) ? 0. : 1.); @}
}

int main()
@{
  double x;
  int    i;

  struct unur_distr *distr,*distr1;  /* distribution */ 
  struct unur_par *par,*par1;      /* parameter */
  struct unur_gen *gen,*gen1;      /* generator */

 
  /* make distr. object: truncated Gaussian */
  distr1 = unur_distr_cont_new();
  unur_distr_cont_set_cdf(distr1, trig );
  unur_distr_cont_set_pdf(distr1,pdftrig );

  /* choose method and set parameters */
  par1 = unur_ninv_new(distr1);
@b{  unur_ninv_use_newton(par1);
 }

  /* make generator object */
 
  gen1 = unur_init(par1);

  /* sample */
  for (i=0;i<100;i++) @{
  x = unur_sample_cont(gen1);
  printf("%f\n",x);
  @}

  /* destroy generator object */
  unur_free(gen1);

  exit (0);
@}
@end smallexample

@node Methods
@chapter Methods

@multitable @columnfractions .25 .25 .25 .25
@item name/references    @tab  parameter (default)   @tab required       @tab remarks
@item AROU               @tab                        @tab pdf, dpdf       @tab Adaptive Ratio-Of-Uniforms
@item CSTD               @tab                        @tab                @tab interface for extern generators
@item DAU                @tab                        @tab prob. vec.     @tab (Discrete) Alias-Urn
@item DIS                @tab                        @tab prob. vec.     @tab (Discrete) Alias-Urn
@item TDR [..]           @tab                        @tab                @tab 
@item NINV               @tab                        @tab                @tab numerical inversion
@item                    @tab  (regula falsi)        @tab cdf            @tab
@item                    @tab  newton                @tab cdf, pdf       @tab only for continous cdf
@item RECT               @tab                        @tab                @tab multi variate experimental
@item STDR               @tab                        @tab pdf, mode,area under pdf       @tab transformed density rejection with universal bounds

@item SROU               @tab                        @tab pdf, mode,area under pdf      @tab (Simple universal generator, ratio-of-uniforms method
@item TABL               @tab                        @tab pdf            @tab Ahren
@item TDR                @tab                        @tab pdf, dpdf      @tab Transformed density rejection
@item UTDR                @tab                        @tab pdf, mode      @tab Universal Transformed Density Rejection; 3-point method

@end multitable

@* choosing the method:
@*  @code{ struct unur_par par = unur_NAME_new(struct unur_distr )
}
@*
@* e.g.: 
@* @code{ par  = unur_ninv_new(distr );
}

@* choosing the parameters of a method. (This can be a change of a
numerical parameter (e.g: 2 ..) or decision of a special numerical
implementation (e.g: Neton- regula falsi)
To change any parameter you habe to use the according function call.
 All parameters have default settings:

@*e.g.:  
@* Numerical inversion with Netwon
@* @code{  unur_ninv_use_newton(par); );
}

@node FAQ
@chapter FAQ
@subsection Q1: I have a simulation program in FORTRAN. How can I use your
library.

Use the following program xyz.c which produce afile with randoom numbers. Read this random numbers ... 

@node Reference
@chapter Function reference
@menu
* DistrRef:: Functions for distributions
* General::       General functions
* MethodsRef::       Functions for Methods
@end menu
Notation:


@node DistrRef
@section distributions

@node General
@section general

@node MethodsRef
@section methods
@menu
* arou:: Adaptive Ratio Of Uniforms
* cstd:: Interface for extern generators
* dau::  (Discrete) Alias-Urn
* dis::  (Discrete) Alias-Urn
* dstd:: ???
* ninv:: Numerical INVersion
* rect:: experimental multivariate Method
* srou:: Simple Ratio Of Uniforms
* stdr:: Transformed Density Rejection (with universal bounds)
* tabl:: Ahren
* tdr::  Trandformed Density Rejection
* unif:: ???
* utdr:: Universal Transformed Density Rejection (3-point method)
@end menu

@include qstart_function_reference.texi


@node Distributions
@chapter distributions

@node Internal
@chapter internals
@section ....
@section Internal remarks 
@enumerate
@item
remark at the very beginning: names of the struct too long (unur_distr, unur_par, unur_gen);
better: one struct unur with unur.d, unur.p, unur.g 
@item
standard configuration: Log outout to file
@end enumerate

@ifhtml
@anchor{Contents}
@end ifhtml
@contents


@bye












