 
\input texinfo   @c -*-texinfo-*-

@c Dies ist das neue UNURAN -Einfuehrung  
@c Juli 2000 Janka & Tirler                
@c $Id$




@c %**start of header
@setfilename qstart.info
@settitle    UNURAN User Manual
@iftex
@afourpaper
@end iftex
@c %**end of header

@dircategory Scientific software
@direntry
* unuran-ref: (unuran-ref).  UNURAN -- Universal Non-Uniform Random number generator
@end direntry


@setchapternewpage odd
@paragraphindent 0


@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
@c
@c `Top' Node and Master Menu
@c
     




@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
@c
@c The Body of the Document
@c


@c @node    Introduction, Structure Overview , Top,      Top
@c @comment node-name,    next,                previous, up
     
@c @menu
@c @c  * Copying::             Your rights and freedoms.
@c * Structure Overview::      Here we show a flow chart in order to elucidate the
@c                             structure of the diffenrent objects.
@c * Routines for User::       The function syntax used in the user
@c                            interface is described here.
@c * Example::                 This chaper provides a short demo program.
@c @end menu

@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
@c
@c Introduction ...
@c
@chapter Introduction
@section Overview
@section Install
@subsection now
cvs update @*
@* 'make' in UNURAN to compile UNURAN
@* Makefile.am in /examples modify in regard to testprogram 
@* make in /examples


@section Getting start
@*Beginning example
@*call the compiler with:
@*gcc -Wall  -L../src/methods  -L../src/distributions  -L../src/tests  -L../src/uniform -g -O2  -o test1  test1.o -lunuran_tests -lunuran_distributions -lunuran -luniform -lprng -lm

Code:

@example

/* my first UNURAN program */ 

#include <unuran.h>
#include <unuran_distributions.h>
#include <unuran_tests.h>



int main()
{
  double x;
  int    i;

  struct unur_distr *distr;  /* distribution */ 
  struct unur_par *par;      /* parameter */
  struct unur_gen *gen;      /* generator */
/* mache neues Verteilungsobjekt unur_distr_cont_new (methods.distr.c)   */
/*     setze pointer auf pdf und cdf  */
 
  /* make distr. object: truncated Gaussian */
  distr = unur_distr_normal(NULL,0);
  unur_distr_cont_set_domain(distr, -2.,2.);

  /* choose method and set parameters */
  par = unur_arou_new(distr);
  unur_arou_set_max_sqhratio(par,0.99);

  /* make generator object */
  gen = unur_init(par);

  /* sample */
  for (i=0;i<100;i++) {
  x = unur_sample_cont(gen);
  printf("%f\n",x);
  }
} 
@end example
 First you have to include the libraries @code{unuran.h} and @code{unuran_distributions.h} with the commands:

@example
#include <unuran.h>
#include <unuran_distributions.h> 
@end example 
This headers provide all functions/features for generating random numbers.
Three structures 
@example
struct unur_distr *distr;  /* distribution */ 
  struct unur_par *par;    /* parameter */
  struct unur_gen *gen;    /* generator */
@end example
are necesssary to store the used parameters. It is not necessary to understand the structure in detail to get random numbers. 
@*
With
@example
 distr = unur_distr_normal(NULL,0);
@end example
we generate an distribution,
and with
@example
 par = unur_arou_new(distr);
@end example
we have genarate the parameters of the method 'arou'
Now its possible to change default parameters of the method with @code {
 unur_arou_set_max_sqhratio(par,0.99);}
@*

@example
gen = unur_init(par)
@end example
we generate an genarator objekt (and destroy the the objects distr.(?) and par)
which is necessary to genarate an non uniform random number with
@example
 x = unur_sample_cont(gen);

@end example

If you know the c.d.f you can genarate +random numbers in the following way
The important lines are in bold face.

@example
/* my second UNURAN program test2.c */ 

#include <unuran.h>
#include <unuran_distributions.h>
#include <unuran_tests.h>
@b{
double trig (double x)
{  return ( (x<0.) ? 0. : (x>1.) ?1. : x ); }  
}
int main()
{
  double x;
  int    i;

  struct unur_distr *distr,*distr1;  /* distribution */ 
  struct unur_par *par,*par1;      /* parameter */
  struct unur_gen *gen,*gen1;      /* generator */
 
  /* make distr. object: truncated Gaussian */
@b{  distr1 = unur_distr_cont_new();
  unur_distr_cont_set_cdf(distr1, trig );
}

  /* choose method and set parameters */
  par1 = unur_ninv_new(distr1);
 
  /* make generator object */
  gen1 = unur_init(par1);


  /* sample */
  for (i=0;i<100;i++) {
  x = unur_sample_cont(gen1);
  printf("%f\n",x);
  }
 


  /* destroy generator object */
  // unur_free(gen);
  unur_free(gen1);

  exit (0);
}
@end example

If want to change the parameters of a method:
The important lines are in bold face.

@example

/* my second UNURAN program test2.c */ 

#include <unuran.h>
#include <unuran_distributions.h>
#include <unuran_tests.h>

double trig (double x)
{  return ( (x<0.) ? 0. : (x>1.) ? 1. : x ); }  
@b{ double pdftrig (double x)
{  return ( (0.<x || x<1.) ? 0. : 1.); }
}

int main()
{
  double x;
  int    i;

  struct unur_distr *distr,*distr1;  /* distribution */ 
  struct unur_par *par,*par1;      /* parameter */
  struct unur_gen *gen,*gen1;      /* generator */

 
  /* make distr. object: truncated Gaussian */
  distr1 = unur_distr_cont_new();
  unur_distr_cont_set_cdf(distr1, trig );
  unur_distr_cont_set_pdf(distr1,pdftrig );

  /* choose method and set parameters */
  par1 = unur_ninv_new(distr1);
@b{  unur_ninv_use_newton(par1);
 }

  /* make generator object */
 
  gen1 = unur_init(par1);

  /* sample */
  for (i=0;i<100;i++) {
  x = unur_sample_cont(gen1);
  printf("%f\n",x);
  }

  /* destroy generator object */
  unur_free(gen1);

  exit (0);
}
@end example

@chapter methods

@multitable @columnfractions .25 .25 .25 .25
@item name/references    @tab  parameter (default)   @tab necessary      @tab remarks
@item TDR [..]           @tab                        @tab                @tab 
@item NINV               @tab                        @tab                @tab numerical inversion
@item                    @tab  (regula falsi)        @tab cdf            @tab
@item                    @tab  newton                @tab cdf, pdf       @tab only for continous cdf
@end multitable

@* choosing the method:
@*  @code{ struct unur_par par = unur_NAME_new(struct unur_distr )
}
@*
@* e.g.: 
@* @code{ par  = unur_ninv_new(distr );
}

@* choosing the parameters of a method. (This can be a change of a
numerical parameter (e.g: 2 ..) or decision of a special numerical
implementation (e.g: Neton- regula falsi)
To change any parameter you habe to use the according function call.
 All parameters have default settings:

@*e.g.:  
@* Numerical inversion with Netwon
@* @code{  unur_ninv_use_newton(par); );
}
 

@chapter Function reference

@unnumberedsubsec unur_distr_normal
@code{ struct unur_distr distr = unur_distr_normal( )}
@* create a distribiution objekt with all necessary parameters for the normal distribution
@unnumberedsubsec unur_distr_cont_new
create a new distribution objekt witout special entries
@unnumberedsubsec  unur_distr_cont_set_cdf
initialize an distribution object with a continous cdf
@unnumberedsubsec unur_init
@code{ struct unur_gen gen = unur_init(struct unur_par);}

@unnumberedsubsec unur_sample_cont


@chapter distributions

@chapter internals
@section ....
@section Internal remarks 
@enumerate
@item
remark at the very beginning: names of the struct too long (unur_distr, unur_par, unur_gen);
better: one struct unur with unur.d, unur.p, unur.g 
@ item
standard configuration: Log outout to file
@end enumerate

@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
@c
@c The End of the Document
@c




@bye












