@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
@c
@c   Routines
@c
@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Structures , Input String , Distribution Library, Top
@comment node-name,   next,          previous,             up

@menu
* Input String::           A string provided by the user sets
                            distribution and generation method.
* Distribution::           The distribution object determines
                            the basic distribution.
* Parameter::              The parameter object sets the parameters for
                            the generator.
* Generator::              The generator object initializes and invokes
                            the generator.
@end menu

@chapter Structures
There are 3 different structures, whose hierarchie is described in the
flow chart in the chapter introduction @ref{Structure Overview}.

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Input String , Distribution, Structures, Structures
@comment node-name,     next,         previous,   up

@section Input String
Description of the input string that enables the user to choose
different parameters, describing the objects we have designed.

@*
@deftp{the object}
@@<objectname> -> <object_description>; @*
In case of default of the object name a standard object is invoked.
@end deftp

@deftp{object_description}
<parameterlist> @*
Description of parameters is not obligatory, on default standard
parameters will be used for generating the object.
@end deftp

@deftp{parameterlist}
<keyword> <operator> <variable> @*
operators can be the following:
<= , < , > , >= , : , =  @*
datatypes of variables can be the following:
double, float, int, pointer, range, string, unsigned long @*
@end deftp
@deftp{additionally spacing operators can be defined}
%<n>
@end deftp

@*
@deftp{Here is a practical example}
In this example we describe definition of the distribution object.

char choose[ ] =  @@distribution -> normal, parameters = (5,2), mode = 1, area = 1, domain = [-2:2];
@end deftp

@enumerate
@deftp{objects}
@item distribution
@item generator
@item urng 
@item sample
@end deftp
@end enumerate



@enumerate
@deftp{object distribution - object_names}
@item Beta
@item Chisquare
@item Exponential
@item Gamma
@item Laplace
@item Lognormal
@item Lomax
@item Normal
@item Pareto
@item Powerexponential
@item Rayleigh
@item Student
@item Uniform
@end deftp
@end enumerate

@deftp{Parameters for distribution object}
parameters = (x,y), mode = x, area = x, domain = [x:y]
@end deftp

@enumerate
@deftp{object generator - object_names}
@item Arou
@item Cstd
@item Dau
@item Dis
@item Tabl
@item Tdr
@item Rect
@item Unif
@item Utdr
@end deftp
@end enumerate

@deftp{Parameters for generator object}
domain = [x:y], domain_vec = x, mode = x, usemode = x, factor = x,
cpoints = x, shratio <= x, intervals <= x, tdr_c = x, tabl_c = x, slopes
= x, variant = x (0,1,2), check = x (0,1), copy = x (0,1), debug = x (0,1)
@end deftp


@sp 2
@deftp{Function}
unur_make_gen(str @var{*choose})
@end deftp

This function contains all function calls necessary to run the
generator and integrates the chosen parameters into them:

@center distr = unur_distr_distribution( double @var{fpar}, int @var{n_fpar} )

@center par = unur_method_new( struct unur_distr @var{*distr} )

@center gen = unur_init( struct unur_par @var{*par} )

These 3 functions have to be called obligatory but additionally, one can
call different set functions to determine certain parameters in each object.


Here are some examples:

unur_distr_set_domain( struct unur_distr @var{*distr}, double
@var{left}, double @var{right} )   
@* @dots{} in this case a parameter of the distribution object is set

unur_set_urng( struct unur_par @var{*par}, UNUR_URNG_TYPE @var{urng} )
@* @dots{} in this case a parameter of the distribution object is set

Alternatively,for some disributions there exist functions that generate a distribution object automatically @ref{Distribution}
    
@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Distribution, Parameter, Input String, Structures
@comment node-name,     next,      previous,     up

@section Distribution
Description of the distribution object.

@*
@deftp{This is what a function for continuous p.d.f.s looks like}
typedef double (unur_function_cont)(double x, double *params, int
n_params)
@end deftp

@deftp{The sturcture}
First of all we have implemented a structure called `struct
unur_distr_cont´. It is defined for univariate continuous distribution
and contains pointers to the p.d.f, to the derivative of the p.d.f and to
the c.d.f.:        

@center unur_function_cont *pdf
@center unur_function_cont *dpdf 
@center unur_function_cont *cdf 
                    
Further, parameters and the number of the parameters of the
p.d.f. are declared here. Finally also the location of the mode, the
area below the p.d.f and the domain boundaries are defined here.
@end deftp

@deftp{The Object}
Now we define the distribution object: `struct unur_distr´.
It contains the structure unur_distr_cont, described above as well as
information about the type (int `type´) of distribution, the number of
parameters changed (int`set´) and a magic cookie.
@end deftp

@deftp{Generate distribution object automatically}
In order to provide a possibility to easily run the desired generator,
we have implemented a function that automatically generates a
distribution object:

@center struct unur_distr *unur_distr_distribution(double @var{*params},
@center int @var{n_params} )
@sp 1
Unfortunately, the list is only available for the following
distributions:
@end deftp
@itemize
@item  beta - distribution
@item cauchy - distribution
@item gamma - distribution
@item normal - distribution
@item uniform - distribution
@end itemize

@sp 2
In order to have the object as modular as possible, we have
defined several function prototypes for manipulating distribution
object
@sp 1

@deftypefn {Library Function} struct unur_distr *unur_distr_new_cont(
                              void )

A new distribution object is created and the type of distribution is
set. The function returns a pointer to the object (`distr´).
@end deftypefn

@deftypefn {Library Function} int unur_distr_set_pdf( struct unur_distr @var{*distr}, void @var{*pdf} )
The function uses the pointers to the distribution object and the p.d.f to set
the p.d.f. of the distribution and returns 1 if successful.
@end deftypefn

@deftypefn {Library Function} int unur_distr_set_dpdf( struct unur_distr @var{*distr}, void @var{*dpdf} )
The function uses the pointers to the distribution object and the d.p.d.f to set
the derivate of p.d.f. of the distribution and returns 1 if successful.
@end deftypefn

@deftypefn {Library Function} int unur_distr_set_cdf( struct unur_distr @var{*distr}, void @var{*cdf} )
The function uses the pointers to the distribution object and the c.d.f to set
the c.d.f. of the distribution and returns 1 if successful.
@end deftypefn

@deftypefn {Library Function} int unur_distr_set_params( struct unur_distr @var{*distr}, double @var{*params}, int @var{n_params} )
This function sets an array of parameters where all the data needed for
the distribution are stored.
@end deftypefn

@deftypefn {Library Function} int unur_distr_set_mode( struct unur_distr @var{*distr}, double @var{mode} )
The mode of the distribution is being set here. If successful, 1 is returned.
@end deftypefn

@deftypefn {Library Function} int unur_distr_set_pdfarea( struct unur_distr @var{*distr}, double @var{area} )
The area below p.d.f. is being set here. If successful, 1 is returned.
@end deftypefn

@deftypefn {Library Function} int unur_distr_set_domain( struct unur_distr @var{*distr}, double
@var{left}, double @var{right} )
This function needs the parameters for the right and left border as well
as the distribution function to set the new borders of the domain of the distribution.
@end deftypefn

@deftypefn {Library Function} void unur_distr_copy( struct unur_distr @var{*distr1}, struct unur_distr @var{*distr2} )
Here we copy distribution object distr2 into distr1. This is necessary
not to loose the set parameters of the object.
@end deftypefn

@deftypefn {Library Function} void unur_distr_free( struct unur_distr @var{*distr} );
This function is necessary to free the allocated memory space of the distribution object.
@end deftypefn




@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Parameter, Generator , Distribution, Structures
@comment node-name, next,       previous,     up

@section Parameter
Description of the parameter object.


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Generator, Function Calls, Parameter, Structures
@comment node-name, next,           previous,  up

@section Generator
Description of the generator object.


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Function Calls , Methods , Generator, Top
@comment node-name,       next,     previous,  up

    
The chapter Function calls  contains documentation of 
various functions. 


@menu 
* Methods:: Different methods to generate random numbers
* Stdgen::  Standard generators
* Tests::   Run various statistical tests, check timing...
* Utils::   Auxilliary Subroutines
@end menu

@chapter Function Calls


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Methods, Arou , Function Calls,      Function Calls
@comment node-name,next, previous,            up

@menu
* Arou::                   Type:continuous univariate random variate 
                           Method:ratio-of uniforms with enveloping polygon
* Cstd::                   Type: continuous univariate random variate
                           Method: generators form standard distribution 
                            (from CRAND)
* Dau::                    Type: discrete random variate
                           Method: alias and alias-urn method
* Dis::                    Type: discrete univariate random variate
                           Method: indexed search (guide table)
* Tabl::                   Type: cantinuous univariate random variate
                           Method: rejection form piecewise constant
                            hat (Ahren´s table method)
* Tdr::                    Type: contiuous univariate random variate
                           Method: transformed density rejection
* Rect::                   Type: continuous multivariate random variate
                           Method: uniformly distributed in rectangle
* Unif::                   Dummy generator, produces uniform random
                            numbers in UNURAN framework
* Utdr::                   Type: continuous univariate random variate
                           Method: transformed density rejection with 
                            three points of contact
* Set::                    Set, change, get parameters for generators
@end menu



@section methods

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Arou,        Cstd , Methods,     Methods
@comment node-name,   next,  previous,    up

@subsection arou



@deftypefn {Library Function} struct unur_par *unur_arou_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}),              double @var{*dpdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}) ) 
...get default parameters for generator             
@end deftypefn

@deftypefn {Library Function} struct unur_gen *unur_arou_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn

@deftypefn {Library Function} double unur_arou_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn

@deftypefn {Library Function} double unur_arou_sample_check( 
struct unur_gen @var{*generator} )                                             
...sample from generator                             
@end deftypefn

@deftypefn {Library Function} void unur_arou_free(
struct unur_gen @var{*generator})                                              
...destroy generator object                          
@end deftypefn     


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Cstd,      Dau , Arou,     Methods
@comment node-name, next, previous, up

@subsection cstd


@deftypefn {Library Function} struct unur_par *unur_cstd_new( 
char @var{*definition} )                                                       
...get default parameters for generator        
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_cstd_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator
@end deftypefn            

@deftypefn {Library Function} double unur_cstd_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_cstd_free( 
struct unur_gen @var{*generator})                                              
...destroy generator object                          
@end deftypefn            
   


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Dau,       Dis , Cstd,     Methods
@comment node-name, next, previous, up

@subsection dau


@deftypefn {Library Function} struct unur_par *unur_dau_new( 
double @var{*probabilities}, int @var{plength})
...get default parameters for generator              
@end deftypefn     

@deftypefn {Library Function} struct unur_gen *unur_dau_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                         
@end deftypefn     

@deftypefn {Library Function} int unur_dau_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator                             
@end deftypefn     

@deftypefn {Library Function} void unur_dau_free( 
struct unur_gen @var{*generator} )                                             
...destroy generator object                          
@end deftypefn     



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Dis,       Tabl, Dau,      Methods
@comment node-name, next, previous, up

@subsection dis


@deftypefn {Library Function} struct unur_par *unur_dis_new( 
double @var{*probabilities}, int @var{plength} )                               
...get default parameters for generator                                      
@end deftypefn     

@deftypefn {Library Function} struct unur_gen *unur_dis_init( 
struct unur_par @var{*parameter} )                                             
...initialize new generator                                                  
@end deftypefn     

@deftypefn {Library Function} unur_dis_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator                            
@end deftypefn
   
@deftypefn {Library Function} void unur_dis_free( 
struct unur_gen @var{*generator} )                                             
...destroy generator object                          
@end deftypefn     


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Tabl,      Tdr,  Dis,      Methods
@comment node-name, next, previous, up

@subsection tabl

@deftypefn {Library Function} struct unur_par *unur_tabl_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}) )                                                                           ...get default parameters for generator             
@end deftypefn     

@deftypefn {Library Function} struct unur_gen *unur_tabl_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn     

@deftypefn {Library Function} double unur_tabl_sample( 
struct @var{unur_gen *generator} )                                             
...sample from generator
@end deftypefn     

@deftypefn {Library Function} double unur_tabl_sample_check( 
struct @var{unur_gen *generator })                                             
...sample from generator                             
@end deftypefn     

@deftypefn {Library Function} void unur_tabl_free( 
struct @var{unur_gen *generator})                                              
...destroy generator object                          
@end deftypefn            


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Tdr,       Rect, Tabl,     Methods
@comment node-name, next, previous, up

@subsection tdr


@deftypefn {Library Function} struct unur_par *unur_tdr_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}),  @*       
double @var{*dpdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}) )@*    
...get default parameters for generator
@end deftypefn            
@ifhtml
<a href= "file:///home/eeyore/staff/mts/local/unuran-0.0.2-jl/doc/unuran-ref.html#SEC40">unif</a href>
@end ifhtml


@deftypefn {Library Function} struct unur_gen *unur_tdr_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn            

@deftypefn {Library Function} double unur_tdr_sample_log( 
struct @var{unur_gen *gen} )
...sample from generator
@end deftypefn            

@deftypefn {Library Function} double unur_tdr_sample_sqrt( 
struct unur_gen @var{*gen} )                                                   
...sample from generator
@end deftypefn            

@deftypefn {Library Function} double unur_tdr_sample_check( 
struct unur_gen @var{*generator} )                                             
...sample from generator                                                     
@end deftypefn            

@deftypefn {Library Function} void unur_tdr_free( 
struct unur_gen @var{*generator})
...destroy generator object                          
@end deftypefn            
   

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Rect,      Unif, Tdr ,  Methods
@comment node-name, next, previous, up

@subsection rect


@deftypefn {Library Function} struct unur_par *unru_rect_new( 
int @var{dim} )                                                                
...get default parameters for generator              
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_rect_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator
@end deftypefn            

@deftypefn {Library Function} void unur_rect_sample_vec( 
struct unur_gen @var{*gen}, double @var{*vec} )                                
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_rect_free ( 
struct unur_gen @var{*generator} )                                             
...destroy generator 
@end deftypefn


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Unif,      Utdr, Rect,     Methods
@comment node-name, next, previous, up

@subsection unif



@deftypefn {Library Function} struct unur_par *unur_unif_new( 
int @var{start}, int @var{skip} )                                              
...get default parameters for generator              
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_unif_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator
@end deftypefn            

@deftypefn {Library Function} double unur_unif_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_unif_free( 
struct unur_gen @var{*generator} )                                             
...destroy generator object                  

@end deftypefn            


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Utdr,      Set,  Unif,     Methods
@comment node-name, next, previous, up

@subsection utdr


@deftypefn {Library Function} struct unur_par *unur_utdr_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}),              double @var{mode})                                                             
...get default parameters for generator             
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_utdr_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn            

@deftypefn {Library Function} double unur_utdr_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} double unur_utdr_sample_check( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_utdr_free( 
struct unur_gen @var{*generator})                                              
...destroy generator object                          
@end deftypefn            
   



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Set,       Stdgen, Utdr,     Methods
@comment node-name, next,   previous, up

@subsection set

@ifhtml
<h3>
@end ifhtml
Parameters for the distribution and its p.d.f.:
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_set_domain( 
struct unur_par @var{*parameter}, double @var{left}, double @var{right} )      
...set the left and right borders of the domain of the distribution          
@end deftypefn            

@deftypefn {Library Function} int unur_set_domain_vec( 
struct unur_par @var{*par}, double @var{**domain} )                            
...set coordinates for domain boundary                                       
@end deftypefn            

@deftypefn {Library Function} int unur_set_pdf_param(  
struct unur_par @var{*parameter}, double @var{*pdf_params}, int @var{n_params} )
...set array of parameters for p.d.f.                                        
@end deftypefn            

@deftypefn {Library Function} int unur_set_mode( 
struct unur_par @var{*parameter}, double @var{mode} )                          
...set mode of p.d.f.                                                        
@end deftypefn            

@deftypefn {Library Function} int unur_set_pdf_area( 
struct unur_par @var{*parameter}, double @var{area} )                          
...set the (approximate) area below the pdf (default value 1.)               
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for generators of univariate discrete distributions:            
@ifhtml
</h3><p></p>
@end ifhtml


@deftypefn {Library Function} int unur_set_factor( 
struct unur_par @var{*parameter}, double @var{factor} )                        
...set factor for relative size of (search|guide|alias) table                
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for generators of univariate continuous distributions:          
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_set_cpoints( struct unur_par @var{*parameter}, int @var{n_stp}, double @var{*starting_cpoints} )                       
...set construction points for hat and/or its number for initialization      
@end deftypefn            

@deftypefn {Library Function} int unur_set_max_ratio( 
struct unur_par @var{*parameter}, double @var{max_ratio} )                     
...set bound for ratio A(squeeze) / A(hat)                                   
@end deftypefn            

@deftypefn {Library Function} int unur_set_max_intervals( 
struct unur_par @var{*parameter}, int @var{max_ivs} )                          
...set maximum number of intervals or segments                               
@end deftypefn            

@deftypefn {Library Function} int unur_set_tdr_c( 
struct unur_par @var{*par}, double @var{c} )                                   
...set parameter c for transformation T_c  (method TDR only)                 
@end deftypefn            

@deftypefn {Library Function} int unur_set_tabl_c( struct @var{unur_par *par}, double @var{c} );
...set parameter for equal area rule  (method TABL only)                     
@end deftypefn            

@deftypefn {Library Function} int unur_set_slopes( 
struct unur_par @var{*par}, double @var{*slopes}, int @var{n_slopes} )         
...set slopes of p.d.f. (method TABL only)                                   
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for generators of mulitvariate continuous distributions:       
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_get_dimension( 
struct unur_gen @var{*gen} )
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for all generators:                                             
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_set_urng( 
struct unur_par @var{*par}, UNUR_URNG_TYPE @var{urng} )                        
...set uniform random number generator                                       
@end deftypefn            

@deftypefn {Library Function} UNUR_URNG_TYPE unur_chg_urng( 
struct unur_gen @var{*gen}, UNUR_URNG_TYPE @var{urng} )                        
...change uniform random number generator                                    
@end deftypefn            

@deftypefn {Library Function} UNUR_URNG_TYPE unur_get_urng( 
struct unur_gen @var{*gen} )                                                   
...get uniform random number generator                                    
@end deftypefn            

@deftypefn {Library Function} int unur_set_variant( 
struct unur_par @var{*par}, unsigned long @var{variant} )                      
...set variant of method                                                     
@end deftypefn            

@deftypefn {Library Function} int unur_set_check(  
struct unur_par @var{*parameter}, int @var{check} )                            
...turn testing of sampling on/off 
@end deftypefn            

@deftypefn {Library Function} int unur_set_copyall(  
struct unur_par @var{*par}, int @var{copy} )                                   
...turn copaing of all inputs into generator object on/off  
@end deftypefn            

@deftypefn {Library Function} int unur_set_debug( 
struct unur_par @var{*parameter}, unsigned long @var{db} )                     
...set debugging flag for generator                                          
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for debugging (defined in debug.c):                             
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} FILE* unur_set_log(FILE @var{*log})
@end deftypefn            

@deftypefn {Library Function} FILE* unur_get_log(void)
@end deftypefn            
    

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Stdgen ,   Tests , Set,      Function Calls
@comment node-name, next,   previous, up


@section stdgen


@deftypefn {Library Function} double nbm( 
UNUR_URNG_TYPE  @var{urng})                                                    
...normal distribution 
@end deftypefn            

@deftypefn {Library Function} double gammarand(  
double @var{a}, UNUR_URNG_TYPE  @var{urng} )                                   
...gamma distribution
@end deftypefn            



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Tests ,    Utils , Stdgen,      Function Calls
@comment node-name, next,   previous,    up


@section tests

@ifhtml
<h4>
@end ifhtml
run battery of tests:                                                   
@ifhtml
<p></h4></p>
@end ifhtml
   
@deftypefn {Library Function} void unur_run_tests( 
struct unur_par @var{*par}, unsigned long @var{tests},                         double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}))
@end deftypefn            

@ifhtml
<h4>
@end ifhtml
particular tests:                                                         
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} void unur_test_printsample( 
struct unur_gen @var{*gen}, int @var{n_rows}, int @var{n_cols} )               
... print a sample
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_test_timing( 
struct unur_par @var{*par}, int @var{log_samplesize} )                         
...timing
@end deftypefn            
         
@deftypefn {Library Function} int unur_test_count_urn( 
struct unur_gen @var{*gen}, int @var{samplesize} )                             
...count used uniform random numbers
@end deftypefn            

@deftypefn {Library Function} double unur_test_chi2( 
struct unur_gen @var{*gen},                                               double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}),            int @var{intervals},                                                      int @var{samplesize},                                                    int @var{classmin},                                                      int @var{output} )                                                       
...chi^2 tests
@end deftypefn            

@deftypefn {Library Function} int unur_make_scatterplot( 
struct unur_gen @var{*gen},                                               double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}))        
...make scatterplot of generated numbers
@end deftypefn            

@deftypefn {Library Function} double _unur_sample_cont_transformed( 
struct unur_gen @var{*gen},                                               double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}) )       
...sample from generator and transform to uniform by means of the c.d.f.
@end deftypefn            
  
@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Utils ,    Common , Tests,    Function Calls
@comment node-name, next,    previous, up

@menu 
* Common::  auxilliary functions in general
* Stream::  functions concerning the determination of the output stream
@end menu


@section utils



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Common ,    Stream , Utils,    Utils
@comment node-name,  next,    previous, up

@subsection common

@ifhtml
<h4>
@end ifhtml
allocate memory :
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} void* _unur_malloc(size_t size);
@end deftypefn            

@ifhtml
<p></p><h4><p></p>
@end ifhtml
debugging tools:
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} char* _unur_make_genid(
char @var{*gentype})
@end deftypefn            

@deftypefn {Library Function} void  _unur_db_error( 
char @var{*genid},                                                        
int @var{errortype},                                                     
char @var{*msg},                                                         
char @var{*filename},                                                    
int @var{line})
@end deftypefn            

@deftypefn {Library Function} void  _unur_db_warning(
char @var{*genid},                                                        
int @var{errortype},                                                     
char @var{*msg},                                                         
char @var{*filename},                                                    
int @var{line})
@end deftypefn            

@deftypefn {Library Function} void  _unur_db_cookie_warning( 
unsigned long @var{expected},                                             
unsigned long @var{observed},                                            
char @var{*filename},                                                    
int @var{line})
@end deftypefn            

@ifhtml
<p></p><h4><p></p>
@end ifhtml
miscellaneous:                                                  
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} double _unur_arcmean( 
double @var{x0},                                                          
double @var{x1} )
@end deftypefn               

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Stream ,    Continuous Distribution , Common,   Utils
@comment node-name,  next,                     previous, up

@subsection stream


@deftp {Output streams}
In case of sucess the output stream is sent to `stdout´ and by default the error stream is sent to `stderr'. Both streams can be turned on/off with a compiler switch  /** TODO **/. 
@end deftp

@deftp {Manipulating the error stream}
You can redirect the error stream to a file on the command line. There are also two ways to change this within your program. Firstly, the stream can be redirected to another file by providing a suitable file pointer. Alternatively you can set up an error stream handler, which is a function that accepts error message strings. By using an error stream handler function you have complete control over where the messages are stored.
@end deftp

@deftypefn {Library Function} 
void _unur_stream_printf( const char @var{*genid}, char @var{*filename},
@center int @var{line}, const char @var{*format}, @dots{})
@end deftypefn        

@deftp {The Function}
In case of an error, this function writes a message (such as ERROR or
WARNING) on the output stream. This message inludes information about
the source file in which the error occurred, the line number in that
file and a description of the error. The dots represent the arguments to
be printed. Filename represents the name of source file (provided by
__FILE__) while line stands for the line number in source file (provided
by __LINE__).
@end deftp

@deftypefn {Library Function} 
FILE * unur_set_stream( FILE * @var{new_stream} )
@end deftypefn            

@deftp {The Function}
This function selects the stream used for UNUR error messages. After
calling ´unur_set_stream´ any further messages sent to the default
stream handler will be printed on NEW_STREAM.The previous stream is
retruned, so that you can close it or restore it later. Note that the
stream is stored un a static variable, so there can only be one error
stream per program.
@end deftp

@deftypefn {Library Function} 
inline FILE * unur_get_stream( void )
@end deftypefn            

@deftp {The Function}
The function opens the logfile where the (error) stream has been printed
and returns a pointer to the output stream.
@end deftp

@deftypefn {Library Function}
static FILE * _unur_logfile_open( const char @var{*logfilename} )
@end deftypefn            

@deftp {The Function}
This function opens the LOG file so the message can be written into the
file closes it after the message has been written and returns the LOG file.
@end deftp

























