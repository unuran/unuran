@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
@c
@c   Routines
@c
@c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Function Calls , Methods , Distribution Library,      Top
@comment node-name,       next,     previous,                  up

    
The chapter Function calls  contains documentation of 
various functions. 


@menu 
* Methods:: Different methods to generate random numbers
* Stdgen::  Standard generators
* Tests::   Run various statistical tests, check timing...
* Utils::   Auxilliary Subroutines
@end menu

@chapter Function Calls


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Methods, Arou , Function Calls,      Function Calls
@comment node-name,next, previous,            up

@menu
* Arou::                   Type:continuous univariate random variate 
                           Method:ratio-of uniforms with enveloping polygon
* Cstd::                   Type: continuous univariate random variate
                           Method: generators form standard distribution 
                            (from CRAND)
* Dau::                    Type: discrete random variate
                           Method: alias and alias-urn method
* Dis::                    Type: discrete univariate random variate
                           Method: indexed search (guide table)
* Tabl::                   Type: cantinuous univariate random variate
                           Method: rejection form piecewise constant
                            hat (Ahren´s table method)
* Tdr::                    Type: contiuous univariate random variate
                           Method: transformed density rejection
* Rect::                   Type: continuous multivariate random variate
                           Method: uniformly distributed in rectangle
* Unif::                   Dummy generator, produces uniform random
                            numbers in UNURAN framework
* Utdr::                   Type: continuous univariate random variate
                           Method: transformed density rejection with 
                            three points of contact
* Set::                    Set, change, get parameters for generators
@end menu



@section methods

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Arou,        Cstd , Methods,     Methods
@comment node-name,   next,  previous,    up

@subsection arou



@deftypefn {Library Function} struct unur_par *unur_arou_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}),              double @var{*dpdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}) ) 
...get default parameters for generator             
@end deftypefn

@deftypefn {Library Function} struct unur_gen *unur_arou_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn

@deftypefn {Library Function} double unur_arou_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn

@deftypefn {Library Function} double unur_arou_sample_check( 
struct unur_gen @var{*generator} )                                             
...sample from generator                             
@end deftypefn

@deftypefn {Library Function} void unur_arou_free(
struct unur_gen @var{*generator})                                              
...destroy generator object                          
@end deftypefn     


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Cstd,      Dau , Arou,     Methods
@comment node-name, next, previous, up

@subsection cstd


@deftypefn {Library Function} struct unur_par *unur_cstd_new( 
char @var{*definition} )                                                       
...get default parameters for generator        
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_cstd_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator
@end deftypefn            

@deftypefn {Library Function} double unur_cstd_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_cstd_free( 
struct unur_gen @var{*generator})                                              
...destroy generator object                          
@end deftypefn            
   


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Dau,       Dis , Cstd,     Methods
@comment node-name, next, previous, up

@subsection dau


@deftypefn {Library Function} struct unur_par *unur_dau_new( 
double @var{*probabilities}, int @var{plength})
...get default parameters for generator              
@end deftypefn     

@deftypefn {Library Function} struct unur_gen *unur_dau_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                         
@end deftypefn     

@deftypefn {Library Function} int unur_dau_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator                             
@end deftypefn     

@deftypefn {Library Function} void unur_dau_free( 
struct unur_gen @var{*generator} )                                             
...destroy generator object                          
@end deftypefn     



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Dis,       Tabl, Dau,      Methods
@comment node-name, next, previous, up

@subsection dis


@deftypefn {Library Function} struct unur_par *unur_dis_new( 
double @var{*probabilities}, int @var{plength} )                               
...get default parameters for generator                                      
@end deftypefn     

@deftypefn {Library Function} struct unur_gen *unur_dis_init( 
struct unur_par @var{*parameter} )                                             
...initialize new generator                                                  
@end deftypefn     

@deftypefn {Library Function} unur_dis_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator                            
@end deftypefn
   
@deftypefn {Library Function} void unur_dis_free( 
struct unur_gen @var{*generator} )                                             
...destroy generator object                          
@end deftypefn     


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Tabl,      Tdr,  Dis,      Methods
@comment node-name, next, previous, up

@subsection tabl

@deftypefn {Library Function} struct unur_par *unur_tabl_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}) )                                                                           ...get default parameters for generator             
@end deftypefn     

@deftypefn {Library Function} struct unur_gen *unur_tabl_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn     

@deftypefn {Library Function} double unur_tabl_sample( 
struct @var{unur_gen *generator} )                                             
...sample from generator
@end deftypefn     

@deftypefn {Library Function} double unur_tabl_sample_check( 
struct @var{unur_gen *generator })                                             
...sample from generator                             
@end deftypefn     

@deftypefn {Library Function} void unur_tabl_free( 
struct @var{unur_gen *generator})                                              
...destroy generator object                          
@end deftypefn            


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Tdr,       Rect, Tabl,     Methods
@comment node-name, next, previous, up

@subsection tdr


@deftypefn {Library Function} struct unur_par *unur_tdr_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}),  @*       
double @var{*dpdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}) )@*    
...get default parameters for generator
@end deftypefn            
@ifhtml
<a href= "file:///home/eeyore/staff/mts/local/unuran-0.0.2-jl/doc/unuran-ref.html#SEC40">unif</a href>
@end ifhtml


@deftypefn {Library Function} struct unur_gen *unur_tdr_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn            

@deftypefn {Library Function} double unur_tdr_sample_log( 
struct @var{unur_gen *gen} )
...sample from generator
@end deftypefn            

@deftypefn {Library Function} double unur_tdr_sample_sqrt( 
struct unur_gen @var{*gen} )                                                   
...sample from generator
@end deftypefn            

@deftypefn {Library Function} double unur_tdr_sample_check( 
struct unur_gen @var{*generator} )                                             
...sample from generator                                                     
@end deftypefn            

@deftypefn {Library Function} void unur_tdr_free( 
struct unur_gen @var{*generator})
...destroy generator object                          
@end deftypefn            
   

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Rect,      Unif, Tdr ,  Methods
@comment node-name, next, previous, up

@subsection rect


@deftypefn {Library Function} struct unur_par *unru_rect_new( 
int @var{dim} )                                                                
...get default parameters for generator              
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_rect_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator
@end deftypefn            

@deftypefn {Library Function} void unur_rect_sample_vec( 
struct unur_gen @var{*gen}, double @var{*vec} )                                
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_rect_free ( 
struct unur_gen @var{*generator} )                                             
...destroy generator 
@end deftypefn


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Unif,      Utdr, Rect,     Methods
@comment node-name, next, previous, up

@subsection unif



@deftypefn {Library Function} struct unur_par *unur_unif_new( 
int @var{start}, int @var{skip} )                                              
...get default parameters for generator              
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_unif_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator
@end deftypefn            

@deftypefn {Library Function} double unur_unif_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_unif_free( 
struct unur_gen @var{*generator} )                                             
...destroy generator object                  

@end deftypefn            


@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Utdr,      Set,  Unif,     Methods
@comment node-name, next, previous, up

@subsection utdr


@deftypefn {Library Function} struct unur_par *unur_utdr_new( 
double @var{*pdf}(double @var{x},double @var{*pdf_param}, int @var{n_pdf_params}),              double @var{mode})                                                             
...get default parameters for generator             
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_utdr_init( 
struct unur_par @var{*parameters} )                                            
...initialize new generator                          
@end deftypefn            

@deftypefn {Library Function} double unur_utdr_sample( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} double unur_utdr_sample_check( 
struct unur_gen @var{*generator} )                                             
...sample from generator
@end deftypefn            

@deftypefn {Library Function} void unur_utdr_free( 
struct unur_gen @var{*generator})                                              
...destroy generator object                          
@end deftypefn            
   



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Set,       Stdgen, Utdr,     Methods
@comment node-name, next,   previous, up

@subsection set

@ifhtml
<h3>
@end ifhtml
Parameters for the distribution and its p.d.f.:
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_set_domain( 
struct unur_par @var{*parameter}, double @var{left}, double @var{right} )      
...set the left and right borders of the domain of the distribution          
@end deftypefn            

@deftypefn {Library Function} int unur_set_domain_vec( 
struct unur_par @var{*par}, double @var{**domain} )                            
...set coordinates for domain boundary                                       
@end deftypefn            

@deftypefn {Library Function} int unur_set_pdf_param(  
struct unur_par @var{*parameter}, double @var{*pdf_params}, int @var{n_params} )
...set array of parameters for p.d.f.                                        
@end deftypefn            

@deftypefn {Library Function} int unur_set_mode( 
struct unur_par @var{*parameter}, double @var{mode} )                          
...set mode of p.d.f.                                                        
@end deftypefn            

@deftypefn {Library Function} int unur_set_pdf_area( 
struct unur_par @var{*parameter}, double @var{area} )                          
...set the (approximate) area below the pdf (default value 1.)               
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for generators of univariate discrete distributions:            
@ifhtml
</h3><p></p>
@end ifhtml


@deftypefn {Library Function} int unur_set_factor( 
struct unur_par @var{*parameter}, double @var{factor} )                        
...set factor for relative size of (search|guide|alias) table                
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for generators of univariate continuous distributions:          
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_set_cpoints( struct unur_par @var{*parameter}, int @var{n_stp}, double @var{*starting_cpoints} )                       
...set construction points for hat and/or its number for initialization      
@end deftypefn            

@deftypefn {Library Function} int unur_set_max_ratio( 
struct unur_par @var{*parameter}, double @var{max_ratio} )                     
...set bound for ratio A(squeeze) / A(hat)                                   
@end deftypefn            

@deftypefn {Library Function} int unur_set_max_intervals( 
struct unur_par @var{*parameter}, int @var{max_ivs} )                          
...set maximum number of intervals or segments                               
@end deftypefn            

@deftypefn {Library Function} int unur_set_tdr_c( 
struct unur_par @var{*par}, double @var{c} )                                   
...set parameter c for transformation T_c  (method TDR only)                 
@end deftypefn            

@deftypefn {Library Function} int unur_set_tabl_c( struct @var{unur_par *par}, double @var{c} );
...set parameter for equal area rule  (method TABL only)                     
@end deftypefn            

@deftypefn {Library Function} int unur_set_slopes( 
struct unur_par @var{*par}, double @var{*slopes}, int @var{n_slopes} )         
...set slopes of p.d.f. (method TABL only)                                   
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for generators of mulitvariate continuous distributions:       
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_get_dimension( 
struct unur_gen @var{*gen} )
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for all generators:                                             
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} int unur_set_urng( 
struct unur_par @var{*par}, UNUR_URNG_TYPE @var{urng} )                        
...set uniform random number generator                                       
@end deftypefn            

@deftypefn {Library Function} UNUR_URNG_TYPE unur_chg_urng( 
struct unur_gen @var{*gen}, UNUR_URNG_TYPE @var{urng} )                        
...change uniform random number generator                                    
@end deftypefn            

@deftypefn {Library Function} UNUR_URNG_TYPE unur_get_urng( 
struct unur_gen @var{*gen} )                                                   
...get uniform random number generator                                    
@end deftypefn            

@deftypefn {Library Function} int unur_set_variant( 
struct unur_par @var{*par}, unsigned long @var{variant} )                      
...set variant of method                                                     
@end deftypefn            

@deftypefn {Library Function} int unur_set_check(  
struct unur_par @var{*parameter}, int @var{check} )                            
...turn testing of sampling on/off 
@end deftypefn            

@deftypefn {Library Function} int unur_set_copyall(  
struct unur_par @var{*par}, int @var{copy} )                                   
...turn copaing of all inputs into generator object on/off  
@end deftypefn            

@deftypefn {Library Function} int unur_set_debug( 
struct unur_par @var{*parameter}, unsigned long @var{db} )                     
...set debugging flag for generator                                          
@end deftypefn            

@ifhtml
<h3><p></p><p></p>
@end ifhtml
Parameters for debugging (defined in debug.c):                             
@ifhtml
</h3><p></p>
@end ifhtml

@deftypefn {Library Function} FILE* unur_set_log(FILE @var{*log})
@end deftypefn            

@deftypefn {Library Function} FILE* unur_get_log(void)
@end deftypefn            
    

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Stdgen ,   Tests , Set,      Function Calls
@comment node-name, next,   previous, up


@section stdgen


@deftypefn {Library Function} double nbm( 
UNUR_URNG_TYPE  @var{urng})                                                    
...normal distribution 
@end deftypefn            

@deftypefn {Library Function} double gammarand(  
double @var{a}, UNUR_URNG_TYPE  @var{urng} )                                   
...gamma distribution
@end deftypefn            



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Tests ,    Utils , Stdgen,      Function Calls
@comment node-name, next,   previous,    up


@section tests

@ifhtml
<h4>
@end ifhtml
run battery of tests:                                                   
@ifhtml
<p></h4></p>
@end ifhtml
   
@deftypefn {Library Function} void unur_run_tests( 
struct unur_par @var{*par}, unsigned long @var{tests},                         double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}))
@end deftypefn            

@ifhtml
<h4>
@end ifhtml
particular tests:                                                         
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} void unur_test_printsample( 
struct unur_gen @var{*gen}, int @var{n_rows}, int @var{n_cols} )               
... print a sample
@end deftypefn            

@deftypefn {Library Function} struct unur_gen *unur_test_timing( 
struct unur_par @var{*par}, int @var{log_samplesize} )                         
...timing
@end deftypefn            
         
@deftypefn {Library Function} int unur_test_count_urn( 
struct unur_gen @var{*gen}, int @var{samplesize} )                             
...count used uniform random numbers
@end deftypefn            

@deftypefn {Library Function} double unur_test_chi2( 
struct unur_gen @var{*gen},                                               double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}),            int @var{intervals},                                                      int @var{samplesize},                                                    int @var{classmin},                                                      int @var{output} )                                                       
...chi^2 tests
@end deftypefn            

@deftypefn {Library Function} int unur_make_scatterplot( 
struct unur_gen @var{*gen},                                               double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}))        
...make scatterplot of generated numbers
@end deftypefn            

@deftypefn {Library Function} double _unur_sample_cont_transformed( 
struct unur_gen @var{*gen},                                               double @var{*cdf}(double @var{x}, double @var{*fparam}, int @var{n_fparam}) )       
...sample from generator and transform to uniform by means of the c.d.f.
@end deftypefn            
  
@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Utils ,    Common , Tests,    Function Calls
@comment node-name, next,    previous, up

@menu 
* Common::  auxilliary functions in general
* Stream::  functions concerning the determination of the output stream
@end menu


@section utils



@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Common ,    Stream , Utils,    Utils
@comment node-name,  next,    previous, up

@subsection common

@ifhtml
<h4>
@end ifhtml
allocate memory :
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} void* _unur_malloc(size_t size);
@end deftypefn            

@ifhtml
<p></p><h4><p></p>
@end ifhtml
debugging tools:
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} char* _unur_make_genid(
char @var{*gentype})
@end deftypefn            

@deftypefn {Library Function} void  _unur_db_error( 
char @var{*genid},                                                        
int @var{errortype},                                                     
char @var{*msg},                                                         
char @var{*filename},                                                    
int @var{line})
@end deftypefn            

@deftypefn {Library Function} void  _unur_db_warning(
char @var{*genid},                                                        
int @var{errortype},                                                     
char @var{*msg},                                                         
char @var{*filename},                                                    
int @var{line})
@end deftypefn            

@deftypefn {Library Function} void  _unur_db_cookie_warning( 
unsigned long @var{expected},                                             
unsigned long @var{observed},                                            
char @var{*filename},                                                    
int @var{line})
@end deftypefn            

@ifhtml
<p></p><h4><p></p>
@end ifhtml
miscellaneous:                                                  
@ifhtml
<p></h4></p>
@end ifhtml

@deftypefn {Library Function} double _unur_arcmean( 
double @var{x0},                                                          
double @var{x1} )
@end deftypefn               

@c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

@node    Stream ,    Continuous Distribution , Common,   Utils
@comment node-name,  next,                     previous, up

@subsection stream


@deftp {Output streams}
In case of sucess the output stream is sent to `stdout´ and by default the error stream is sent to `stderr'. Both streams can be turned on/off with a compiler switch  /** TODO **/. 
@end deftp

@deftp {Manipulating the error stream}
You can redirect the error stream to a file on the command line. There are also two ways to change this within your program. Firstly, the stream can be redirected to another file by providing a suitable file pointer. Alternatively you can set up an error stream handler, which is a function that accepts error message strings. By using an error stream handler function you have complete control over where the messages are stored.
@end deftp

@deftypefn {Library Function} 
void _unur_stream_printf( const char @var{*genid}, char @var{*filename},
@center int @var{line}, const char @var{*format}, @dots{})
@end deftypefn        

@deftp {The Function}
In case of an error, this function writes a message (such as ERROR or
WARNING) on the output stream. This message inludes information about
the source file in which the error occurred, the line number in that
file and a description of the error. The dots represent the arguments to
be printed. Filename represents the name of source file (provided by
__FILE__) while line stands for the line number in source file (provided
by __LINE__).
@end deftp

@deftypefn {Library Function} 
FILE * unur_set_stream( FILE * @var{new_stream} )
@end deftypefn            

@deftp {The Function}
This function selects the stream used for UNUR error messages. After
calling ´unur_set_stream´ any further messages sent to the default
stream handler will be printed on NEW_STREAM.The previous stream is
retruned, so that you can close it or restore it later. Note that the
stream is stored un a static variable, so there can only be one error
stream per program.
@end deftp

@deftypefn {Library Function} 
inline FILE * unur_get_stream( void )
@end deftypefn            

@deftp {The Function}
The function opens the logfile where the (error) stream has been printed
and returns a pointer to the output stream.
@end deftp

@deftypefn {Library Function}
static FILE * _unur_logfile_open( const char @var{*logfilename} )
@end deftypefn            

@deftp {The Function}
This function opens the LOG file so the message can be written into the
file closes it after the message has been written and returns the LOG file.
@end deftp

























