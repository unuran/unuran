/*****************************************************************************
 *                                                                           *
 *          UNURAN -- Universal Non-Uniform Random number generator          *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 *   FILE:      stringpars.c.base / stringpars.c                             *
 *                                                                           *
 *                                                                           *
 *   DESCRIPTION:                                                            *
 *                                                                           *
 *   The file stringpars.c.base contains the base of the stringparser.       *
 *   The perl script <name-it> replaces the                                  *
 *        =INPUT keyword                                                     *
 *   tags with information found within the source-code and writes it to     *
 *   'stringpars.c'.                                                         *
 *   The string to parse contains information about the standard             *
 *   distribution, the choosen method and (optional) the uniform number      *
 *   generator -- The distribution block must be first.                      *
 *   These three blocks must be separeted with colons `:'                    *
 *                                                                           *
 *   The string holds information about the standard distribution            *
 *   to sample from and (optional) about the sampling method and the         *
 *   uniform random number generator invoked.                                *
 *   Therefore the the string consists of up to three block which must be    *
 *   seperated with a colon `:'.                                             *
 *   The standard distribution block must be first!                          *
 *                                                                           *
 *   Within each block a piece of information must be provided using         *
 *   a <key>=<value> scheme.                                                 *
 *   If more then one piece of information is needed,                        *
 *   the <key>=<value> pairs must be separeted with semicolons `;'.          *
 *   The <key> is a keyword explained below.                                 *
 *   The value can be a string, a number or a list of numbers or a string    *
 *   followed by a list of numbers (examples will be given below),           *
 *   depending on the <key>. A list must be  bounded with parentheses        *
 *   `(' and `)' and the list separator is a komma `,'.                      *
 *   If the value is a string and a list in beetween only white space        *
 *   is allowed.                                                             *
 *                                                                           *
 *   Distribution:                                                           *
 *   The key `distr' is obligatory, it must be first and the corresponding   *
 *   value must be one  of the implemented standard distributions---with     *
 *   a list of parameters.  e.g.: distr=normal(0,1)                          *
 *   Furthermore it's possible to set the domain via the key `domain'.       *
 *                                                                           *
 *   Method:                                                                 *
 *   The key `method' is obligatory, it must be first and the value must be  *
 *   the name of a method suitable for the choosen standard distribution.    *
 *   e.g.: method=arou                                                       *
 *   Of course the following keys dependend on the method choosen at first.  *
 *   All corresponding `_set_' commands of UNURAN are available and the key  *
 *   is the string after the `unur_<methodname>_set_' part of the command.   *
 *   e.g.: UNURAN provides the command `unur_arou_set_max_sqhratio' to       *
 *   set a parameter. To call this function via the string-interface, the    *
 *   key `max_sqhratio' can be used.                                         *
 *   If this block is omitted, UNURAN chooses a suitable method.             *
 *                                                                           *
 *   Uniform random number generator:                                        *
 *   The only key allowed is `prng' and the following value is a             *
 *   string which is passed as it is to the PRNG package                     *
 *   For information see the PRNG manual                                     *
 *   If this block is omitted, UNURAN sets a uniform random number generator *
 *                                                                           *
 *****************************************************************************
     $Id$
 *****************************************************************************
 *                                                                           *
 *   Copyright (c) 2000 Wolfgang Hoermann and Josef Leydold                  *
 *   Dept. for Statistics, University of Economics, Vienna, Austria          *
 *                                                                           *
 *   This program is free software; you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation; either version 2 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program; if not, write to the                           *
 *   Free Software Foundation, Inc.,                                         *
 *   59 Temple Place, Suite 330, Boston, MA 02111-1307, USA                  *
 *                                                                           *
 *****************************************************************************/

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <source_unuran.h>



/*---------------------------------------------------------------------------*/
/* Variants: none                                                            */

/*---------------------------------------------------------------------------*/
/* Debugging flags                                                           */
/*    bit  01    ... pameters and structure of generator (do not use here)   */
/*    bits 02-12 ... setup                                                   */
/*    bits 13-24 ... adaptive steps                                          */
/*    bits 25-32 ... trace sampling                                          */

#define STRING_DEBUG_INIT    0x00000010u   /* print parameters               */

/*---------------------------------------------------------------------------*/
/* Flags for logging set calls                                               */

/*---------------------------------------------------------------------------*/

#define GENTYPE "STRING"       /* (pseudo) type of generator                 */

/*---------------------------------------------------------------------------*/

#ifdef UNUR_ENABLE_LOGGING
/*---------------------------------------------------------------------------*/
/* the following functions print debugging information on output stream,     */
/* i.e., into the log file if not specified otherwise.                       */
/*---------------------------------------------------------------------------*/

static void _unur_str_debug_string( int level, const char *key, const char *value );
/*---------------------------------------------------------------------------*/
/* print string into log file.                                               */
/*---------------------------------------------------------------------------*/

static void _unur_str_debug_par_set( int level, const char *key, const char *type, ... );


#endif





/* Maximal length of provides string allowed */
#define MAX_STRLENGTH (2048)
/* Maximal entries of any list allowed */
#define MAX_ELEM (2048)


#define MAX_SET_ARGS  (10)  /* maximal number of arguments for set calls (must be at least 2) */

/* function prototypes */

static UNUR_DISTR * _unur_str2distr        (char *);
UNUR_GEN   * unur_str2gen           (char *);
static int          _unur_str2urng         (UNUR_PAR *, char *);



static UNUR_PAR   * _unur_str2par ( char *strmethod, UNUR_DISTR *distr );


static UNUR_PAR *_unur_str_par_new( const char *method, UNUR_DISTR *distr );
static int _unur_str_par_set( UNUR_PAR *par, const char *key, char *value );


static int  _unur_parse_dlist_xx (char *, double *);
static int  _unur_parse_dlist (char *, double **);
static void _unur_prepare_string (char *str);

static int _unur_atoi ( const char *str );
static unsigned _unur_atou ( const char *str );
static double _unur_atod ( const char *str );

/* ... */
typedef int void_set( UNUR_PAR *par );
typedef int i_set( UNUR_PAR *par, int i );
typedef int u_set( UNUR_PAR *par, unsigned u );
typedef int d_set( UNUR_PAR *par, double d );
typedef int dd_set( UNUR_PAR *par, double d1, double d2 );
typedef int iD_set( UNUR_PAR *par, int size, double *array );
typedef int Di_set( UNUR_PAR *par, double *array, int size );

static int _unur_str_par_set_void (UNUR_PAR *par, const char *key, char *type_args, char **args, void_set set);
static int _unur_str_par_set_i (UNUR_PAR *par, const char *key, char *type_args, char **args, i_set set);
static int _unur_str_par_set_u (UNUR_PAR *par, const char *key, char *type_args, char **args, u_set set);
static int _unur_str_par_set_d (UNUR_PAR *par, const char *key, char *type_args, char **args, d_set set);
static int _unur_str_par_set_dd (UNUR_PAR *par, const char *key, char *type_args, char **args, dd_set set);
static int _unur_str_par_set_iD (UNUR_PAR *par, const char *key, char *type_args, char **args, iD_set set);
static int _unur_str_par_set_Di (UNUR_PAR *par, const char *key, char *type_args, char **args, Di_set set);
 





/*---------------------------------------------------------------------------*/

struct unur_par *
_unur_str2par( char *str_method, UNUR_DISTR *distr )
     /*----------------------------------------------------------------------*/
     /* get parameter object for distribution and method                     */
     /*                                                                      */
     /* parameters:                                                          */
     /*   str_method ... string that contains method description             */
     /*   distr      ... pointer to distribution object                      */
     /*                                                                      */
     /* return:                                                              */
     /*   default parameters (pointer to structure)                          */
     /*                                                                      */
     /* error:                                                               */
     /*   return NULL                                                        */
     /*----------------------------------------------------------------------*/
{
  struct unur_par *par = NULL;     /* pointer to parameter object */

  char *token;             /* pointer to token in string */
  char *next;              /* pointer to next token in string */
  char *key, *value;       /* the key and its value */

  /* tokenize the string using ';' as separator and handle the tokens */
  for ( token = next = str_method;
	next != NULL && *token != '\0';
	token = next ) {

    /* find end of token (i.e. the pointer to next token) */
    next = strchr(token,';');
    if (next != NULL) {
      /* next separator found */
      *next = '\0';     /* terminate token string    */
      next++;           /* set pointer to next token */
    }

    /* token points to a key */
    key = token;

    /* get the value from the pair key=value and terminate key string */
    value = strchr(key, '=');
    if (value != NULL) {
      *value = '\0';    /* terminate key string        */
      value++;          /* set pointer to value string */
    }

    /* get (default) parameter object for method */
    if ( !strcmp( key, "method") ) {
      if (key == str_method) {
	/* "method" must be the first key */
	par = _unur_str_par_new(value,distr);
      }
      else {
	_unur_error(GENTYPE,UNUR_ERR_GENERIC,"method must be first key"); 
	return NULL;
      }
    }

    /* set parameters */
    else {
      if (par != NULL) {
	if ( !_unur_str_par_set(par, key, value) ) {
	  ;
	}
      }
      else {
	_unur_error(GENTYPE,UNUR_ERR_GENERIC,"method not set"); 
	return NULL;
      }
    }

  }

  /* end */
  return par;

} /* end of _unur_str2par() */

/*---------------------------------------------------------------------------*/

struct unur_par *
_unur_str_par_new( const char *method, UNUR_DISTR *distr )
     /*----------------------------------------------------------------------*/
     /* get new parameter object for method                                  */
     /*                                                                      */
     /* parameters:                                                          */
     /*   method ... string that contains method name                        */
     /*   distr  ... pointer to distribution object                          */
     /*                                                                      */
     /* return:                                                              */
     /*   default parameters (pointer to structure)                          */
     /*                                                                      */
     /* error:                                                               */
     /*   return NULL                                                        */
     /*----------------------------------------------------------------------*/
{
  struct unur_par *par = NULL;
  
#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_string(1,"method",method);
#endif

=INPUT list_of_methods

   if (par == NULL) {
     unur_errno = UNUR_ERR_GENERIC;
     _unur_stream_printf ( GENTYPE,__FILE__,__LINE__,
			   "error: %s: unknown method or invalid data: %s",
			   unur_get_strerror(unur_errno), method );
   }

   return par;
} /* end of _unur_str_par_new() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set( UNUR_PAR *par, const char *key, char *value )
     /*----------------------------------------------------------------------*/
     /* set parameters for method                                            */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par   ... pointer to parameter for building generator object       */
     /*   key   ... string that contains key for parameter                   */
     /*   value ... string that contains list of arguments for parameter     */
     /*                                                                      */
     /* return:                                                              */
     /*   1 ... on success                                                   */
     /*   0 ... on error                                                     */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{
  int result = FALSE;      /* result of UNURAN set call (0 or 1) */

  char *token;             /* pointer to token in string */
  char *next;              /* pointer to next token in string */

  /* storing arguments of set calls: */
  int n_args;                      /* number of arguments in set call */
  char type_args[MAX_SET_ARGS+1];  /* array containing info about arguments */
  char *args[MAX_SET_ARGS+1];      /* pointers to argument strings */

  /* initialize pointers */
  n_args = 0;
  *type_args = '\0';
  *args = NULL;

  /* we have two types of arguments:
     't' ... a single token, or
     'L' ... a list, indicated by (...)
  */

  /* split value string into separate arguments */
  if (value && *value != '\0') {
    /* there is at least one argument */

    for ( token = next = value;
	  next != NULL && *token != '\0' && n_args < MAX_SET_ARGS;
	  token = next, n_args++ ) {
      
      /* get type of argument */

      if ( *value == '(' ) {
	/* argument is a list */
	type_args[n_args] = 'L';
	/* skip to next character */
	token++;
	/* store pointer to argument */
	args[n_args] = token;
	/* find end of list using ')' as terminating character */
	next = strchr(token,')');
	if (next != NULL) {
	  /* end of list found */
	  *next = '\0';      /* terminate token string    */
	  token = ++next;    /* set pointer to first character after ')' */
	  /* first character after ')' must be ',' */
	  if ( !(*token == ',' || *token == '\0') ) {
	    _unur_error(GENTYPE,UNUR_ERR_GENERIC,") not followed by comma"); 
	    return FALSE;
	  }
	}
	else {
	  /* no ')' found */
	  token = NULL;
	}
      }

      else {
	/* argument is a sigle item */
	type_args[n_args] = 't';
	/* store pointer to argument */
	args[n_args] = token;
      }

      /* find end of argument string using ',' as separator */
      if (token) {
	next = strchr(token,',');
	if (next != NULL) {
	  /* next separator found */
	  *next = '\0';     /* terminate token string    */
	  next++;           /* set pointer to next token */
	}
      }
      else {
	next = NULL;
      }
    }

    /* terminate string */
    type_args[n_args] = '\0';

    /* If there are two many arguments, we simply assume a syntax error */
    /* (This case should not happen.)                                   */
    if (n_args >= MAX_SET_ARGS) { 
      _unur_error( GENTYPE, UNUR_ERR_GENERIC, "too many arguments");
      result = FALSE;
    }
  }

  /* find and execute set call */
=INPUT list_of_par_sets

   if (result == FALSE) {
     unur_errno = UNUR_ERR_GENERIC;
     _unur_stream_printf ( GENTYPE,__FILE__,__LINE__,
			   "error: %s: unknown parameter or invalid data for method: %s",
			   unur_get_strerror(unur_errno), key );
   }

   return result;

} /* end of _unur_str_par_set() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set_void (UNUR_PAR *par, const char *key, char *type_args, char **args, void_set set)
     /*----------------------------------------------------------------------*/
     /* Set parameter in given parameter object.                             */
     /* The list of arguments and their types are given as string.           */
     /*                                                                      */
     /* type: void   (no arguments required)                                 */
     /*                                                                      */
     /* input: void  (no arguments should be given)                          */
     /*                                                                      */
     /* action:                                                              */
     /*    execute set call.                                                 */
     /*    warning if any argument is given.                                 */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par       ... pointer to parameter object                          */
     /*   key       ... name of parameter to be set                          */
     /*   type_args ... contains types of arguments. Possible values:        */
     /*                   't'   for single token                             */
     /*                   'L'   for a list                                   */
     /*   args      ... array of pointers to argument strings                */
     /*   set       ... pointer to UNURAN function for set call              */
     /*                                                                      */
     /* return:                                                              */
     /*   return code from set call, i.e.                                    */
     /*      1 ... on success                                                */
     /*      0 ... on error                                                  */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{

#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_par_set(2,key,"v");
#endif

  if (*type_args != '\0')
    _unur_warning(GENTYPE,UNUR_ERR_GENERIC,"too many argument(s)");

  return set(par);

} /* end of _unur_str_par_set_void() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set_i (UNUR_PAR *par, const char *key, char *type_args, char **args, i_set set)
     /*----------------------------------------------------------------------*/
     /* Set parameter in given parameter object.                             */
     /* The list of arguments and their types are given as string.           */
     /*                                                                      */
     /* type: "i"   (int)                                                    */
     /*                                                                      */
     /* input: "t"  (exactly one single token)                               */
     /*                                                                      */
     /* action:                                                              */
     /*    convert token to int.                                             */
     /*    execute set call.                                                 */
     /*    error if input != "t"                                             */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par       ... pointer to parameter object                          */
     /*   key       ... name of parameter to be set                          */
     /*   type_args ... contains types of arguments. Possible values:        */
     /*                   't'   for single token                             */
     /*                   'L'   for a list                                   */
     /*   args      ... array of pointers to argument strings                */
     /*   set       ... pointer to UNURAN function for set call              */
     /*                                                                      */
     /* return:                                                              */
     /*   return code from set call, i.e.                                    */
     /*      1 ... on success                                                */
     /*      0 ... on error                                                  */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{
  int iarg;

  if ( strcmp(type_args, "t") ) {
    _unur_error(GENTYPE,UNUR_ERR_GENERIC,"invalid argument(s)");
#ifdef UNUR_ENABLE_LOGGING
    /* write info into log file */
    _unur_str_debug_par_set(2,key,"!");
#endif
    return 0;
  }
  
  iarg = _unur_atoi( args[0] );

#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_par_set(2,key,"i",iarg);
#endif

  return set(par,iarg);

} /* end of _unur_str_par_set_i() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set_u (UNUR_PAR *par, const char *key, char *type_args, char **args, u_set set)
     /*----------------------------------------------------------------------*/
     /* Set parameter in given parameter object.                             */
     /* The list of arguments and their types are given as string.           */
     /*                                                                      */
     /* type: "u"   (unsigned)                                               */
     /*                                                                      */
     /* input: "t"  (exactly one single token)                               */
     /*                                                                      */
     /* action:                                                              */
     /*    convert token to unsigned.                                        */
     /*    execute set call.                                                 */
     /*    error if input != "t"                                             */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par       ... pointer to parameter object                          */
     /*   key       ... name of parameter to be set                          */
     /*   type_args ... contains types of arguments. Possible values:        */
     /*                   't'   for single token                             */
     /*                   'L'   for a list                                   */
     /*   args      ... array of pointers to argument strings                */
     /*   set       ... pointer to UNURAN function for set call              */
     /*                                                                      */
     /* return:                                                              */
     /*   return code from set call, i.e.                                    */
     /*      1 ... on success                                                */
     /*      0 ... on error                                                  */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{
  unsigned uarg;

  if ( strcmp(type_args, "t") ) {
    _unur_error(GENTYPE,UNUR_ERR_GENERIC,"invalid argument(s)");
#ifdef UNUR_ENABLE_LOGGING
    /* write info into log file */
    _unur_str_debug_par_set(2,key,"!");
#endif
    return 0;
  }
  
  uarg = _unur_atou( args[0] );

#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_par_set(2,key,"u",uarg);
#endif

  return set(par,uarg);

} /* end of _unur_str_par_set_u() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set_d (UNUR_PAR *par, const char *key, char *type_args, char **args, d_set set)
     /*----------------------------------------------------------------------*/
     /* Set parameter in given parameter object.                             */
     /* The list of arguments and their types are given as string.           */
     /*                                                                      */
     /* type: "d"   (double)                                                 */
     /*                                                                      */
     /* input: "t"  (exactly one single token)                               */
     /*                                                                      */
     /* action:                                                              */
     /*    convert token to double.                                          */
     /*    execute set call.                                                 */
     /*    error if input != "t"                                             */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par       ... pointer to parameter object                          */
     /*   key       ... name of parameter to be set                          */
     /*   type_args ... contains types of arguments. Possible values:        */
     /*                   't'   for single token                             */
     /*                   'L'   for a list                                   */
     /*   args      ... array of pointers to argument strings                */
     /*   set       ... pointer to UNURAN function for set call              */
     /*                                                                      */
     /* return:                                                              */
     /*   return code from set call, i.e.                                    */
     /*      1 ... on success                                                */
     /*      0 ... on error                                                  */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{
  double darg;

  if ( strcmp(type_args, "t") ) {
    _unur_error(GENTYPE,UNUR_ERR_GENERIC,"invalid argument(s)");
#ifdef UNUR_ENABLE_LOGGING
    /* write info into log file */
    _unur_str_debug_par_set(2,key,"!");
#endif
    return 0;
  }
  
  darg = _unur_atod( args[0] );

#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_par_set(2,key,"d",darg);
#endif

  return set(par,darg);

} /* end of _unur_str_par_set_d() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set_dd (UNUR_PAR *par, const char *key, char *type_args, char **args, dd_set set)
     /*----------------------------------------------------------------------*/
     /* Set parameter in given parameter object.                             */
     /* The list of arguments and their types are given as string.           */
     /*                                                                      */
     /* type: "dd"   (double,double)                                         */
     /*                                                                      */
     /* input: "tt"  (exactly two single tokens)                             */
     /*        "L"   (exactly one list)                                      */
     /*                                                                      */
     /* action:                                                              */
     /*    if "tt": convert both to double.                                  */
     /*             execute set call.                                        */
     /*    if "L":  convert list entries to double.                          */
     /*             execute set call with first two entries.                 */
     /*                (error if list has less than two entries)             */
     /*    otherwise: error                                                  */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par       ... pointer to parameter object                          */
     /*   key       ... name of parameter to be set                          */
     /*   type_args ... contains types of arguments. Possible values:        */
     /*                   't'   for single token                             */
     /*                   'L'   for a list                                   */
     /*   args      ... array of pointers to argument strings                */
     /*   set       ... pointer to UNURAN function for set call              */
     /*                                                                      */
     /* return:                                                              */
     /*   return code from set call, i.e.                                    */
     /*      1 ... on success                                                */
     /*      0 ... on error                                                  */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{
  double *darray = NULL;
  double darg[2];
  int result;

  /* either exactly two arguments are given */
  if ( !strcmp(type_args, "tt") ) {
    darg[0] = _unur_atod( args[0] );
    darg[1] = _unur_atod( args[1] );

#ifdef UNUR_ENABLE_LOGGING
    /* write info into log file */
    _unur_str_debug_par_set(2,key,"dd",darg[0],darg[1]);
#endif

    return set( par,darg[0],darg[1] );
  }

  /* or one list with 2 entries is given */
  else if ( !strcmp(type_args, "L") ) {
    if ( _unur_parse_dlist( args[0], &darray ) < 2 ) {
      _unur_error(GENTYPE,UNUR_ERR_GENERIC,"invalid argument(s)");
      free (darray);
#ifdef UNUR_ENABLE_LOGGING
      /* write info into log file */
      _unur_str_debug_par_set(2,key,"!");
#endif
      return 0;
    }
    result = set( par,darray[0],darray[1] );

#ifdef UNUR_ENABLE_LOGGING
    /* write info into log file */
    _unur_str_debug_par_set(2,key,"dd",darray[0],darray[1] );
#endif

    free (darray);
    return result;
  }
  
  else {
    _unur_error(GENTYPE,UNUR_ERR_GENERIC,"invalid argument(s)");
#ifdef UNUR_ENABLE_LOGGING
    /* write info into log file */
    _unur_str_debug_par_set(2,key,"!");
#endif
    return 0;
  }

} /* end of _unur_str_par_set_dd() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set_iD (UNUR_PAR *par, const char *key, char *type_args, char **args, iD_set set)
     /*----------------------------------------------------------------------*/
     /* Set parameter in given parameter object.                             */
     /* The list of arguments and their types are given as string.           */
     /*                                                                      */
     /* type: "iD"   (int, array of doubles)                                 */
     /*                                                                      */
     /* input: "tL"  (single token & list)                                   */
     /*        "L"   (exactly one list)                                      */
     /*        "t"   (single token)                                          */
     /*                                                                      */
     /* action:                                                              */
     /*    if "L":  convert list to array of doubles.                        */
     /*             execute set with size if array as first argument.        */
     /*    if "t":  convert token to int.                                    */ 
     /*             execute set call with NULL as its second argument.       */
     /*    if "tL": convert list to array of doubles.                        */
     /*             convert first token to int.                              */
     /*             set int to min of int and size of array.                 */
     /*             execute set call with int and array.                     */
     /*    otherwise: error                                                  */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par       ... pointer to parameter object                          */
     /*   key       ... name of parameter to be set                          */
     /*   type_args ... contains types of arguments. Possible values:        */
     /*                   't'   for single token                             */
     /*                   'L'   for a list                                   */
     /*   args      ... array of pointers to argument strings                */
     /*   set       ... pointer to UNURAN function for set call              */
     /*                                                                      */
     /* return:                                                              */
     /*   return code from set call, i.e.                                    */
     /*      1 ... on success                                                */
     /*      0 ... on error                                                  */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{
  int result;
  int t_size;
  int size = -1;
  double *darray = NULL;

  /* either an integer and a list are given */
  if ( !strcmp(type_args, "tL") ) {
    t_size = _unur_atoi( args[0] );
    size = _unur_parse_dlist( args[1], &darray );
    if (size > 0) {
      if (size > t_size)  size = t_size;
    }
    else {
      /* empty list */
      size = t_size;
      if (darray) free (darray);
      darray = NULL;
    }
  }

  /* or only an integer is given */
  else if ( !strcmp(type_args, "t") ) {
    size = _unur_atoi( args[0] );
    darray = NULL;
  }
  
  /* or only a list is given */
  else if ( !strcmp(type_args, "L") ) {
    size = _unur_parse_dlist( args[0], &darray );
  }
  
  /* or there is a syntay error */
  if ( !(size>0) ) {
    _unur_error(GENTYPE,UNUR_ERR_GENERIC,"invalid argument(s)");
#ifdef UNUR_ENABLE_LOGGING
    /* write info into log file */
    _unur_str_debug_par_set(2,key,"!");
#endif
    return 0;
  }
  
  /* execute set command */
  result = set( par,size,darray );

#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_par_set(2,key,"iD",size,darray,size);
#endif

  if (darray) free (darray);

  return result;

} /* end of _unur_str_par_set_iD() */

/*---------------------------------------------------------------------------*/

int
_unur_str_par_set_Di (UNUR_PAR *par, const char *key, char *type_args, char **args, Di_set set)
     /*----------------------------------------------------------------------*/
     /* Set parameter in given parameter object.                             */
     /* The list of arguments and their types are given as string.           */
     /*                                                                      */
     /* type: "Di"   (array of doubles, int)                                 */
     /*                                                                      */
     /* input: "Lt"  (list & single token & list)                            */
     /*                                                                      */
     /* action:                                                              */
     /*    convert list to array of doubles.                                 */
     /*    convert token to int.                                             */
     /*    execute set call with array and int.                              */
     /*                                                                      */
     /* parameters:                                                          */
     /*   par       ... pointer to parameter object                          */
     /*   key       ... name of parameter to be set                          */
     /*   type_args ... contains types of arguments. Possible values:        */
     /*                   't'   for single token                             */
     /*                   'L'   for a list                                   */
     /*   args      ... array of pointers to argument strings                */
     /*   set       ... pointer to UNURAN function for set call              */
     /*                                                                      */
     /* return:                                                              */
     /*   return code from set call, i.e.                                    */
     /*      1 ... on success                                                */
     /*      0 ... on error                                                  */
     /*                                                                      */
     /* error:                                                               */
     /*   return 0                                                           */
     /*----------------------------------------------------------------------*/
{
  int result;
  int size;
  double *darray = NULL;

  if ( !strcmp(type_args, "Lt") ) {
    size = _unur_atoi( args[1] );
    size = _unur_parse_dlist( args[0], &darray );
    if (size > 0) {
      result = set( par,darray,size );
#ifdef UNUR_ENABLE_LOGGING
      /* write info into log file */
      _unur_str_debug_par_set(2,key,"v");
#endif
      if (darray) free (darray);

      return result;
    }
  }

  /* there is a syntax error */
  _unur_error(GENTYPE,UNUR_ERR_GENERIC,"invalid argument(s)");
#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_par_set(2,key,"!");
#endif

  return 0;
} /* end of _unur_str_par_set_Di() */

/*---------------------------------------------------------------------------*/

struct unur_distr *
_unur_str2distr(char *str_distr)
     /*----------------------------------------------------------------------*/
     /* get parameter object for distribution and method                     */
     /*                                                                      */
     /* parameters:                                                          */
     /*   str_distr ... string that contains description of distribution     */
     /*                                                                      */
     /* return:                                                              */
     /*   distribution object                                                */
     /*                                                                      */
     /* error:                                                               */
     /*   return NULL                                                        */
     /*----------------------------------------------------------------------*/
{
  struct unur_distr *distr = NULL;



  double list[MAX_ELEM]; /* value contains a list of numbers */
  int no_of_elem=0;        /* size of that list */

  char * tmpstr;     /* temporary pointer to string */

  char * token;      /* char pointer to tokenize the string */
  char *key, *value; /* the key and its value */

  /* tokenize the string -- split at ';' */
  for ( token  = strtok(str_distr, ";"); 
        token != NULL;     
        token  = strtok(NULL, ";") ){

    /* determine key and value */
    key = token;
    value = strchr(key, '=');

    /* none ore more '=' seperates key from value */
    if ( value != NULL ){
       for ( *value='\0',value++  ;  *value=='='  ;  value++ ); 

       /* split value into value and list (one of them must exist) */
       no_of_elem = 0;
       /* is a list beginning with '(' in the value included? */
       if (NULL != strchr(value, '(') ){

         tmpstr = strchr(value, '(');
         *tmpstr = '\0'; /* terminate value */
         tmpstr++;       /* points to begin of list (if available) */
   
         /* extract list of doubles from string  */
         no_of_elem = _unur_parse_dlist_xx(tmpstr ,list);
       }

       /* value must terminate before the first Komma */
       if ( NULL != strchr(value, ',' ) ){
          tmpstr = strchr(value, ',');
          *tmpstr = '\0';                 /* terminate value */
       }

    }

    /* Now: key, value and list are determined               */


    /* ********************************************************** */ 
    /* ********************************************************** */ 
    /* the following code is automatic generated by a perl script */

=INPUT distrinfo

    /* end of automatically generated code */
    /* ********************************************************** */ 
    /* ********************************************************** */ 

  } /* end while -- all tokens handled */


  return distr;

} /* end of _unur_str2distr() */

/*---------------------------------------------------------------------------*/






#if 0
/**********************************************************************/
/*                                                                    */
/* function: _unur_str2distr()                                        */
/*                                                                    */
/* called by: unur_str2gen()                                          */
/*                                                                    */
/* parameters: pointer to char (string)                               */
/*                                                                    */
/* return: pointer to distribution object                             */
/*                                                                    */
/* comments:                                                          */
/* gets a string with information about the distribution,             */
/* generates the corresponding distribution object and returns it     */
/*                                                                    */
/* The string consists of key=value entries separeted by `;'          */
/*                                                                    */
/* three possibilities:                                               */
/* key=value                                                          */
/* key=(komma separated list of numbers)                              */
/* key=value(komma separated list of numbers)                         */
/*                                                                    */
/**********************************************************************/
UNUR_DISTR *_unur_str2distrxx(char *str){

  UNUR_DISTR *distr;

  double list[MAX_ELEM]; /* value contains a list of numbers */
  int no_of_elem;        /* size of that list */

  char * tmpstr;     /* temporary pointer to string */

  char * token;      /* char pointer to tokenize the string */
  char *key, *value; /* the key and its value */

  /* tokenize the string -- split at ';' */
  for ( token  = strtok(str, ";"); 
        token != NULL;     
        token  = strtok(NULL, ";") ){

    /* determine key and value */
    key = token;
    value = strchr(key, '=');

    /* none ore more '=' seperates key from value */
    if ( value != NULL ){
       for ( *value='\0',value++  ;  *value=='='  ;  value++ ); 

       /* split value into value and list (one of them must exist) */
       no_of_elem = 0;
       /* is a list beginning with '(' in the value included? */
       if (NULL != strchr(value, '(') ){

         tmpstr = strchr(value, '(');
         *tmpstr = '\0'; /* terminate value */
         tmpstr++;       /* points to begin of list (if available) */
   
         /* extract list of doubles from string  */
         no_of_elem = _unur_parse_dlist_xx(tmpstr ,list);
       }

       /* value must terminate before the first Komma */
       if ( NULL != strchr(value, ',' ) ){
          tmpstr = strchr(value, ',');
          *tmpstr = '\0';                 /* terminate value */
       }

    }

    /* Now: key, value and list are determined               */


    /* ********************************************************** */ 
    /* ********************************************************** */ 
    /* the following code is automatic generated by a perl script */

=INPUT distrinfo

    /* end of automatically generated code */
    /* ********************************************************** */ 
    /* ********************************************************** */ 

  } /* end while -- all tokens handled */


  return ( distr );

}
/* end of _unur_str2distrxx()                                            */

#endif

/**********************************************************************/

/*---------------------------------------------------------------------------*/



/**********************************************************************/
/*                                                                    */
/* function: _unur_str2urng()                                         */
/*                                                                    */
/* called by: unur_str2gen()                                          */
/*                                                                    */
/* parameters: pointer to parameter object                            */
/*             pointer to char array / string                         */
/*                                                                    */
/* return: error-code                                                 */         
/*                                                                    */
/* comments:                                                          */
/* gets a pointer to a parameter object and a string with             */
/* information about the uniform random number generator (urng)       */
/* and sets the urng withing the parameter object.                    */
/*                                                                    */
/* The string must be as specified within the PRNG package            */
/*                                                                    */
/**********************************************************************/
int _unur_str2urng(UNUR_PAR *par, char *urngstr){

   char *tmpchar;
   UNUR_URNG *urng;
   

   /* split key and value */
   tmpchar = urngstr;
   urngstr = strchr(tmpchar, '=');
   while (*urngstr == '='){
      *urngstr = '\0';
      urngstr++;
   }
   /* only possible key: `prng' */
   if (  0 != strcmp(tmpchar, "prng") ){
      fprintf(stderr, "SYNTAX ERROR: Unknown key for setting uniform random number generator : %s\n",tmpchar);
   }
   
   /* set uniform random number generator */
   urng = prng_new(urngstr);
   unur_set_urng(par, urng); 

   /* error while setting uniform random number generator */
   if ( urng == NULL ){
      fprintf(stderr, "PRNG ERROR: Can't set uniform number generator.\n");
      return (0);
   }
   else{                /* success */
      return (1);
   }
} /* end fo _unur_str2urng() */






/**********************************************************************/
/*                                                                    */
/* function: unur_str2gen()                                           */
/*                                                                    */
/* parameters:  pointer to char array / string                        */
/*                                                                    */
/* return: pointer to generator object                                */
/*                                                                    */
/* comments:                                                          */
/* gets a string with information about the distribution and          */
/* the desired method and                                             */
/* generates the corresponding generator object invoking              */
/* the functions                                                      */
/*   make_dist_obj() and                                              */
/*   _unur_str2parxx()                                                  */
/*                                                                    */
/* The string consists of two substrings (separated by `:')           */
/* (distributio info, method info )                                   */
/* and each of this strings consists of key=value                     */
/*  entries separeted by `;'                                          */
/*                                                                    */
/* three possibilities:                                               */
/* key=value                                                          */
/* key=(komma separated list of numbers)                              */
/* key=value(komma separated list of numbers)                         */
/*                                                                    */
/**********************************************************************/
UNUR_GEN *unur_str2gen (char *str){

  UNUR_DISTR *distr;       /* distribution object */
  UNUR_PAR *par;           /* parameter object */
  UNUR_GEN *gen;           /* generator object    */

  char *diststr; /* string describing distribution */
  char *methstr; /* string describing method       */
  char *urngstr; /* string holding info for uniform generator */
  char *tmpchar; /* temporary pointer to char      */


  char nix[2048];

  /* Prepare string for processing:                               */
  /*   Remove all white spaces and convert to lower case letters. */
  _unur_prepare_string( str );

#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
  _unur_str_debug_string(0,"[input]",str);
#endif


  tmpchar = str;

  /* split info about distribution, method und uniform generator */
  diststr = strtok(tmpchar, ":");
  methstr = strtok(NULL, ":");
  urngstr = strtok(NULL, ":");


  /* no method info but prng info provided */
  if ( urngstr == NULL && methstr != NULL && ( 0==strncmp(methstr, "prng", 4) ) ){
     urngstr = methstr;
     methstr = NULL;
  }

  /* swap methstr and urngstr if necessary */
  if (  methstr != NULL && (0 != strncmp(methstr, "method", 6)) ){
     tmpchar = methstr;
     methstr = urngstr;
     urngstr = tmpchar;
  }


  /* generate distribution object */
  distr = _unur_str2distr(diststr);
  if ( distr == NULL ){
     fprintf(stderr, "ERROR: Can't create parameter object.\n");
  }

  /* generate parameter object */
  if ( methstr != NULL ){ /* method info is provided */
    /* junk */
    strcpy(nix,methstr);
    par = _unur_str2par(nix, distr);
    /* end junk */

  }
  else{ /* no info about method provided -> standard method */
    par = unur_cstd_new(distr);
  }

  /* check if parameter object was generated successfully */
  if ( par == NULL ){
     fprintf(stderr, "ERROR: Can't create parameter object.\n");
  }

  /* set uniform random number generator -- if provided */
  if ( urngstr != NULL ){
     _unur_str2urng(par, urngstr);
  }

  /* generate generator object */
  gen = unur_init(par);
  if ( gen == NULL ){
     fprintf(stderr, "ERROR: Can't create generator object.\n");
  }



#ifdef UNUR_ENABLE_LOGGING
  /* write info into log file */
    _unur_str_debug_string(0,"",NULL);
#endif


  /* return generator object to calling routine */
  return (gen);

} /* end of unur_str2gen() */


/*---------------------------------------------------------------------------*/

int 
_unur_parse_dlist_xx( char *liststr, double *darray )
     /*----------------------------------------------------------------------*/
     /* Process a comma separated list of numbers (doubles), convert it to   */
     /* doubles and store it an array. The list (string) is terminated by    */
     /* by a closing parenthesis ')' or '\0'.                                */
     /*                                                                      */
     /* parameters:                                                          */
     /*   liststr ... string containing list of numbers                      */
     /*   darray  ... pointer to double array for storing result             */
     /*                                                                      */
     /* return:                                                              */
     /*   number of elements extracted                                       */
     /*----------------------------------------------------------------------*/
{
  int n_darray = 0; /* number of elements in processed list */

  /* extract doubles from string and write them to array of doubles   */
  /* end of list is indicated by right bracket ')' or '\0' */  
  while ( *liststr != ')' && *liststr != '\0' ) {
    /* there can only be ',' or '(' in front of the numbers           */
    while ( *liststr == ',' || *liststr == '(' ){
      liststr++; /* next char */
    }
    
    /* extract double and write to array and increase counter */
    darray[n_darray] = strtod(liststr, &liststr);
    n_darray++;

  } /* end while -- all elements of list read */

  return n_darray;

} /* end of _unur_parse_dlist_xx() */

/*---------------------------------------------------------------------------*/

int 
_unur_parse_dlist( char *liststr, double **darray )
     /*----------------------------------------------------------------------*/
     /* Process a comma separated list of numbers (doubles), convert it to   */
     /* doubles and store it an array. The list (string) is terminated by    */
     /* by a closing parenthesis ')' or '\0'.                                */
     /*                                                                      */
     /* parameters:                                                          */
     /*   liststr ... string containing list of numbers                      */
     /*   darray  ... pointer to adress of double array for storing result   */
     /*                                                                      */
     /* return:                                                              */
     /*   number of elements extracted                                       */
     /*                                                                      */
     /* comment:                                                             */
     /*   as a side effect a double array of appropriate size is allocated.  */
     /*----------------------------------------------------------------------*/
{
  double *darr = NULL;  /* pointer to double array */
  int n_darray = 0;     /* number of elements in processed list */
  int n_alloc = 0;      /* number allocated elements */
  char *tailstr;        /* pointer to the remaining string in strtod() */

  /* extract doubles from string and write them to array of doubles   */
  /* end of list is indicated by right bracket ')' or '\0' */  
  while ( *liststr != ')' && *liststr != '\0' ) {
    /* there can only be ',' or '(' in front of the numbers           */
    while ( *liststr == ',' || *liststr == '(' ){
      liststr++; /* next char */
    }

    /* check if there is enough space in darr */
    if (n_darray >= n_alloc) {
      /* no --> allocate memory */
      n_alloc += 100;
      darr = _unur_realloc( darr, n_alloc * sizeof(double) );
    }

    /* extract double and write to array and increase counter */
    darr[n_darray] = strtod(liststr, &tailstr);

    if (liststr == tailstr) {
      /* conversion failed */
      _unur_error(GENTYPE,UNUR_ERR_GENERIC,"cannot convert float"); 
      free(darr);
      darr = NULL;
      n_darray = -1;
      break;
    }
    else {
      /* conversion successfully */
      liststr = tailstr;
      n_darray++;
    }
  } /* end while -- all elements of list read */

  /* store pointer to double array */
  *darray = darr;

  /* return number of elements in array */
  return n_darray;

} /* end of _unur_parse_dlist() */

/*---------------------------------------------------------------------------*/

void
_unur_prepare_string( char *str )
     /*----------------------------------------------------------------------*/
     /* Prepare string for processing:                                       */
     /*   Remove all white spaces and convert to lower case letters.         */
     /*                                                                      */
     /* parameters:                                                          */
     /*   str      ... pointer to string                                     */
     /*----------------------------------------------------------------------*/
{
  char *tmp;

  /* copy characters but skip all white spaces */
  for (tmp = str; *tmp != '\0'; tmp++)
    if ( !isspace(*tmp) ) {
      *str = tolower(*tmp);
      str++;
    }

  /* terminate string */
  *str = '\0';

} /* end of _unur_prepare_string() */

/*---------------------------------------------------------------------------*/

int 
_unur_atoi ( const char *str )
     /*----------------------------------------------------------------------*/
     /* Converts the string into its integer representation.                 */
     /* 'true' and 'on' are converted to 1, 'false' and 'off' to 0.          */
     /*                                                                      */
     /* parameters:                                                          */
     /*   str      ... pointer to string                                     */
     /*                                                                      */
     /* return:                                                              */
     /*   integer                                                            */
     /*----------------------------------------------------------------------*/
{
  if ( !strcmp(str,"true") || !strcmp(str,"on") )
    return 1;

  else if ( !strcmp(str,"false") || !strcmp(str,"off") )
    return 0;

  else
    return atoi(str);

} /* end of _unur_atoi() */

/*---------------------------------------------------------------------------*/

unsigned
_unur_atou ( const char *str )
     /*----------------------------------------------------------------------*/
     /* Converts the string into its unsigned representation.                */
     /* strings are interprated as hexadecimal numbers.                      */
     /* 'true' and 'on' are converted to 1u, 'false' and 'off' to 0u.        */
     /*                                                                      */
     /* parameters:                                                          */
     /*   str      ... pointer to string                                     */
     /*                                                                      */
     /* return:                                                              */
     /*   unsigned                                                           */
     /*----------------------------------------------------------------------*/
{
  char *tail;

  if ( !strcmp(str,"true") || !strcmp(str,"on") )
    return 1u;

  else if ( !strcmp(str,"false") || !strcmp(str,"off") )
    return 0u;

  else
    return ((unsigned) strtoul(str, &tail, 16));
} /* end of _unur_atou() */

/*---------------------------------------------------------------------------*/

double
_unur_atod ( const char *str )
     /*----------------------------------------------------------------------*/
     /* Converts the string into its double value.                           */
     /*                                                                      */
     /* parameters:                                                          */
     /*   str      ... pointer to string                                     */
     /*                                                                      */
     /* return:                                                              */
     /*   double                                                             */
     /*----------------------------------------------------------------------*/
{
    return atof(str);
} /* end of _unur_atod() */

/*---------------------------------------------------------------------------*/

/*****************************************************************************/
/**  Debugging utilities                                                    **/
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
#ifdef UNUR_ENABLE_LOGGING
/*---------------------------------------------------------------------------*/

static void 
_unur_str_debug_string( int level, const char *key, const char *value  )
     /*----------------------------------------------------------------------*/
     /* write info about generator into logfile                              */
     /*                                                                      */
     /* parameters:                                                          */
     /*   level ... level of indentation                                     */
     /*   key   ... pointer to key string                                    */
     /*   value ... pointer to value string                                  */
     /*----------------------------------------------------------------------*/
{
  FILE *log;
  
  log = unur_get_stream();

/*    fprintf(log,"%s: String Interface for UNURAN\n",GENTYPE); */
  fprintf(log,"%s: ",GENTYPE);
  for (; level>0; level--) 
    fprintf(log,"\t");
  fprintf(log,"%s",key);
  if (value)
    fprintf(log,": %s\n",value);
  fprintf(log,"\n");

/*    fprintf(log,"%s:\n",GENTYPE); */

} /* end of _unur_str_debug_string() */

/*---------------------------------------------------------------------------*/

void
_unur_str_debug_par_set( int level, const char *key, const char *type, ... )
     /*----------------------------------------------------------------------*/
     /* write info about generator into logfile                              */
     /*                                                                      */
     /* parameters:                                                          */
     /*   level ... level of indentation                                     */
     /*   key   ... pointer to key string                                    */
     /*   value ... pointer to value string                                  */
     /*----------------------------------------------------------------------*/
{
  va_list ap;
  FILE *log;
  
  va_start(ap, type);

  log = unur_get_stream();

  /* print key name */
  fprintf(log,"%s: ",GENTYPE);
  for (; level>0; level--) 
    fprintf(log,"\t");
  fprintf(log,"%s: ",key);

  while (1) {

    switch (*type) {
    case 'v':
      fprintf(log," -none-");
      break;
    case 'd':
      fprintf(log," %g",va_arg(ap,double));
      break;
    case 'i':
      fprintf(log," %d",va_arg(ap,int));
      break;
    case 'u':
      fprintf(log," %x",va_arg(ap,unsigned int));
      break;
    case 'D': {
      int i,size;
      double *darray;
      darray = va_arg(ap,double *);
      size = va_arg(ap,int);
      if (size > 0) {
	fprintf(log," (%g",darray[0]);
	for (i=1; i<size; i++)
	  fprintf(log,",%g",darray[i]);
	fprintf(log,")");
      }
      else
	fprintf(log," (empty)");
      break;
    }
    case '!':
    default:
      fprintf(log," syntax error");
      break;
    }

    if ( *(++type) != '\0' )
      /* skip. there is a next argument to be processed */
      fprintf(log,",");
    else
      /* done */
      break;
  }

  /* dd, iD, Di */

  fprintf(log,"\n");
  fflush(log);   /* in case of a segmentation fault */

  va_end(ap);

} /* end of _unur_str_debug_par_set() */

/*---------------------------------------------------------------------------*/
#endif   /* end UNUR_ENABLE_LOGGING */
/*---------------------------------------------------------------------------*/
