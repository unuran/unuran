# $Id$
#############################################################################

[main]

[main - data:]

# method (for information only: the program scans the file name)
method: DSROU

# which uniform random number generator should be used for testing
# Mersenne Twister as URNG
urng: mt19937(82456)

[main - header:]

/* prototypes */
int unur_dsrou_set_pedantic( struct unur_par *par, int pedantic );

double pmf( int k, UNUR_DISTR *distr );


double pdf( double x, UNUR_DISTR *distr );
double pdf_sqrtlin( double x, UNUR_DISTR *distr );
double dpdf_sqrtlin( double x, UNUR_DISTR *distr );
double cdf_sqrtlin( double x, UNUR_DISTR *distr );
double pdf_sqrtlinshft(double x, UNUR_DISTR *distr );
double dpdf_sqrtlinshft( double x, UNUR_DISTR *distr );
double cdf_sqrtlinshft( double x, UNUR_DISTR *distr );



static int COMPARE_SAMPLE_SIZE = 10000;
static int VIOLATE_SAMPLE_SIZE = 20;

#############################################################################

[new]

[new - invalid NULL ptr: 
   distr = NULL; ]

~( distr );
	--> expected_NULL --> UNUR_ERR_NULL

[new - invalid distribution type:
   distr = unur_distr_cont_new(); ]

~( distr );
	 --> expected_NULL --> UNUR_ERR_DISTR_INVALID

[new - data missing in distribution object:
   distr = unur_distr_discr_new(); ]

/* pmf, mode, pmfsum */
~( distr );
	--> expected_NULL --> UNUR_ERR_DISTR_REQUIRED

/* mode, pmfsum */
unur_distr_discr_set_pmf(distr,pmf);
~( distr );
	--> expected_NULL --> UNUR_ERR_DISTR_REQUIRED

/* pmfsum */
unur_distr_discr_set_mode(distr,0);
~( distr );
	--> expected_NULL --> UNUR_ERR_DISTR_REQUIRED

#############################################################################

[set]

[set - invalid NULL ptr: 
   par = NULL; ]

~_cdfatmode(par,0.);
	--> expected_setfailed --> UNUR_ERR_NULL

~_verify(par,1);
	--> expected_setfailed --> UNUR_ERR_NULL

[set - invalid parameter object:
   double fpar[2] = {10,0.63};
   distr = unur_distr_binomial(fpar,2);
   par = unur_dari_new(distr); ]

~_cdfatmode(par,0.);
	--> expected_setfailed --> UNUR_ERR_PAR_INVALID

~_verify(par,1);
	--> expected_setfailed --> UNUR_ERR_PAR_INVALID

free(par);

[set - invalid parameters:
   double fpar[2] = {10.,0.63};
   distr = unur_distr_binomial(fpar,2);
   par = unur_dsrou_new(distr); ]

~_cdfatmode(par,-1.);
	--> expected_setfailed --> UNUR_ERR_PAR_SET

free(par);

#############################################################################

[get]

#############################################################################

[chg]

[chg - invalid generator object:
   double fpar[2] = {10.,0.63};
   distr = unur_distr_binomial(fpar,2);
   par = unur_dari_new(distr);
   unur_set_debug(par,0);
   gen = unur_init( par ); <-- ! NULL ]

~_verify(gen,1);
	--> expected_setfailed --> UNUR_ERR_GEN_INVALID

~_domain(gen,0,5);
	--> expected_setfailed --> UNUR_ERR_GEN_INVALID

~_mode(gen,6);
	--> expected_setfailed --> UNUR_ERR_GEN_INVALID

~_cdfatmode(gen,1.);
	--> expected_setfailed --> UNUR_ERR_GEN_INVALID

~_pmfsum(gen,1.);
	--> expected_setfailed --> UNUR_ERR_GEN_INVALID

[chg - invalid parameters:
   double fpar[2] = {10.,0.63};
   distr = unur_distr_binomial(fpar,2);
   par = unur_dsrou_new(distr);
   gen = unur_init( par ); <-- ! NULL ]

~_pmfparams(gen,NULL,1);
	--> expected_setfailed --> UNUR_ERR_NULL

~_pmfparams(gen,fpar,UNUR_DISTR_MAXPARAMS+10);
	--> none --> UNUR_ERR_DISTR_NPARAMS

~_pmfparams(gen,fpar,-1);
	--> expected_setfailed --> UNUR_ERR_DISTR_NPARAMS

~_cdfatmode(gen,-1.);
	--> expected_setfailed --> UNUR_ERR_PAR_SET

~_domain(gen,1.,-1.);
	--> expected_setfailed --> UNUR_ERR_DISTR_SET

~_pmfsum(gen,-1.);
	--> expected_setfailed --> UNUR_ERR_DISTR_SET

#############################################################################

[init]

[init - invalid NULL ptr: 
   par = NULL; ]

unur_init( par );
	--> expected_NULL --> UNUR_ERR_NULL


[init - invalid data:
   distr = unur_distr_discr_new();
   unur_distr_discr_set_pmf(distr,pmf);
   unur_distr_discr_set_mode(distr,2);
   unur_distr_discr_set_pmfsum(distr,1.);
   par = unur_dsrou_new(distr); ]

unur_init( par );
	--> expected_NULL --> UNUR_ERR_GEN_DATA

#############################################################################

[reinit]

[reinit - exist:
   double fpar[2] = {10.,0.63};
   distr = unur_distr_binomial(fpar,2);
   par = unur_dsrou_new(distr);
   gen = unur_init( par ); <-- ! NULL ]

~( gen );
	--> expected_reinit

#############################################################################

[sample]

[sample - compare:
   double fpar[2] = {10.,0.63};
   distr = unur_distr_binomial(fpar,2);
   par = NULL; ]

/* default algorithm */
par = unur_dsrou_new(distr);
        -->compare_int_sequence_par_start

/* default algorithm - verifying mode */
par = unur_dsrou_new(distr);
unur_dsrou_set_verify(par,1);
        -->compare_int_sequence_par


[sample - violate condition:
   double fpar[2] = {10.,0.63};
   distr = unur_distr_binomial(fpar,2);
   par = NULL; ]

/* use cdf at mode */
par = unur_dsrou_new(distr);
unur_dsrou_set_cdfatmode(par,0.4);
        --> run_verify_generator --> UNUR_ERR_GEN_CONDITION

#############################################################################

[validate]

[validate - generators:]

# default variant
par[0] = unur_dsrou_new(@distr@);

# use cdf at mode
{ double Fmode = unur_distr_discr_eval_cdf( unur_distr_discr_get_mode(@distr@), @distr@ );
par[1] = unur_dsrou_new(@distr@);
unur_dsrou_set_cdfatmode(par,Fmode); }

# default variant but reinitialized with changed domain
par[2] = unur_dsrou_new(@distr@);
unur_dsrou_chg_domain(gen,2,7);
unur_dsrou_upd_pmfsum(gen);
unur_dsrou_upd_mode(gen);
unur_dsrou_reinit(gen);	

# default variant but reinitialized with changed pdf parameters
par[3] = unur_dsrou_new(@distr@);
fpm[0] = 10.;
fpm[1] = 0.63;
unur_srou_chg_pdfparams(gen,fpm,2);
unur_srou_upd_pdfarea(gen);
unur_srou_upd_mode(gen);
unur_srou_reinit(gen);	

[validate - distributions:]

# geometric disctribution
fpm[0] = 0.5;
distr[0] = unur_distr_geometric(fpm,1);

fpm[0] = 0.1;
distr[1] = unur_distr_geometric(fpm,1);

fpm[0] = 0.001;
distr[2] = unur_distr_geometric(fpm,1);

# logarithmic distribution
fpm[0] = 0.1;
distr[3] = unur_distr_logarithmic(fpm,1);

fpm[0] = 0.9;
distr[4] = unur_distr_logarithmic(fpm,1);

# negative binomial distribution
fpm[0] = 0.5;
fpm[1] = 10.;
distr[5] = unur_distr_negativebinomial(fpm,2);

fpm[0] = 0.7;
fpm[1] = 5.;
distr[6] = unur_distr_negativebinomial(fpm,2);

fpm[0] = 0.1;
fpm[1] = 20.;
distr[7] = unur_distr_negativebinomial(fpm,2);

# poisson distribution
fpm[0] = 3.;
distr[8] = unur_distr_poisson(fpm,1);

fpm[0] = 50.;
distr[9] = unur_distr_poisson(fpm,1);

# zipf distribution
fpm[0] = 2.;
fpm[1] = 1.;
distr[10] = unur_distr_zipf(fpm,2);

# binomial distribution
fpm[0] = 20.;
fpm[1] = 0.8;
distr[11] = unur_distr_binomial(fpm,2);

# binomial distribution
fpm[0] = 2000.;
fpm[1] = 0.0013;
distr[12] = unur_distr_binomial(fpm,2);

# Hyper geometric distribution
fpm[0] = 2000.;
fpm[1] = 200.;
fpm[2] = 20;
distr[13] = unur_distr_hypergeometric(fpm,3);

# Hyper geometric distribution
fpm[0] = 2000.;
fpm[1] = 200.;
fpm[2] = 220;
distr[14] = unur_distr_hypergeometric(fpm,3);


# number of distributions: 15

[validate - test chi2:]

#  + ... pass test
#  0 ... fail to initialize generator (given variant does not exist)
#  - ... fail test
#  . ... do not run test
#  # ... comment
#
# generators:
#   [0] ... default
#   [1] ... use cdf at mode-1
#   [2] ... default variant but reinitialized with changed domain
#   [3] ....default variant but reinitialized with changed pdf parameters
#
#gen	0   1   2   3   # distribution
#----------------------------------------------------
<0>     +   +   +   .	# geometric (0.5)
<1>     +   +   +   .	# geometric (0.1)
<2>     +   +   +   .	# geometric (0.001)
<3>     +   +   .   .	# logarithmic (0.1)
<4>     +   +   +   .	# logarithmic (0.9)
<5>     +   +   +   .	# negativebinomial (0.5, 10)
<6>     +   +   +   .	# negativebinomial (0.7, 5)
<7>     +   +   .   .	# negativebinomial (0.1, 20)
<8>     +   +   +   .	# poisson (3)
<9>     +   +   +   .	# poisson (20)
##<10>	.   .   .   .   # zipf (2, 1)
<11>    +   +   +   +	# binomial (20, 0.8)
<12>    +   +   +   +	# binomial (2000, 0.0013)
<13>    +   +   +   .	# hypergeometric (2000, 200, 20)
<14>    +   +   .   .	# hypergeometric (2000, 200, 220)

# number of distributions: 15


[validate - verify hat:]

#  + ... pass test
#  ~ ... fail in at most 1% of samples
#  0 ... fail to initialize generator
#  - ... fail test
#  . ... do not run test
#  # ... comment
#
#
# generators:
#   [0] ... default
#   [1] ... use cdf at mode-1
#   [2] ... default variant but reinitialized with changed domain
#   [3] ....default variant but reinitialized with changed pdf parameters
#
#gen	0   1   2   3   # distribution
#----------------------------------------------------
<0>     +   +   +   .	# geometric (0.5)
<1>     +   +   +   .	# geometric (0.1)
<2>     +   +   +   .	# geometric (0.001)
<3>     +   +   .   .	# logarithmic (0.1)
<4>     +   +   +   .	# logarithmic (0.9)
<5>     +   +   +   .	# negativebinomial (0.5, 10)
<6>     +   +   +   .	# negativebinomial (0.7, 5)
<7>     +   +   .   .	# negativebinomial (0.1, 20)
<8>     +   +   +   .	# poisson (3)
<9>     +   +   +   .	# poisson (20)
##<10>	.   .   .   .   # zipf (2, 1)
<11>    +   +   +   +	# binomial (20, 0.8)
<12>    +   +   +   +	# binomial (2000, 0.0013)
<13>    +   +   +   .	# hypergeometric (2000, 200, 20)
<14>    +   +   .   .	# hypergeometric (2000, 200, 220)

# number of distributions: 15


#############################################################################
#############################################################################

[verbatim]

/* pmf that does not work */
double pmf( int k, UNUR_DISTR *distr )
{ 
  return ((k==2) ? 0. : pow(0.5,k));
} /* end of pmf */

double pmf_invalidmode( int k, UNUR_DISTR *distr )
{ 
  return ((k==2) ? 0.01 : pow(0.5,k));
} /* end of pmf */


/* pdf with piecewise linear function as transformed density with T = -1/sqrt */
double pdf_sqrtlin( double x, UNUR_DISTR *distr )
{ 
	double y = 1./(fabs(x)+1.);
	return y*y;
}
double dpdf_sqrtlin( double x, UNUR_DISTR *distr )
{ 
	double y = 1./(fabs(x)+1.);
	y = 2.*y*y*y;
	return ((x<0.) ? y : - y);
}
double cdf_sqrtlin( double x, UNUR_DISTR *distr )
{ 
	if (x<=0.)
		return 0.5/(1.-x);
	else
		return (1.-0.5/(1.+x));
}

/* pdf with piecewise linear function as transformed density with T = -1/sqrt and shifted mode */
double pdf_sqrtlinshft( double x, UNUR_DISTR *distr )
{ 
	double y;
	x -= 1000.;
	y = 1./(fabs(x)+1.);
	return y*y;
}
double dpdf_sqrtlinshft( double x, UNUR_DISTR *distr )
{ 
	double y;
	x -= 1000.;
	y = 1./(fabs(x)+1.);
	y = 2.*y*y*y;
	return ((x<0.) ? y : - y);
}
double cdf_sqrtlinshft( double x, UNUR_DISTR *distr )
{ 
	x -= 1000.;
	if (x<=0.)
		return 0.5/(1.-x);
	else
		return (1.-0.5/(1.+x));
}

/* no such function */
int unur_dsrou_set_pedantic( struct unur_par *par, int pedantic )
{ return 1; }

#############################################################################
