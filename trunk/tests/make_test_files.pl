#!/usr/bin/perl

$| =1;

############################################################
# $Id$

sub usage {
    my $progname = $0;
    $progname =~ s#^.*/##g;

    print STDERR <<EOM;
usage: $progname <test.conf> 
      
Scans <test.conf> and generates a C file with test routines.
File must have suffix "conf".

EOM

    exit;
}

############################################################

use English;

############################################################

############################################################
#                                                          #
#  main                                                    #
#                                                          #
############################################################

# get file names

# program name ...
$name_program = $0;
$name_program =~ s#^.*/##g;

# read in input file name from argument list ...
$file_in = shift;
(usage and die) unless $file_in;

#check suffix
(usage and die) unless ($file_in =~ /\.conf$/);

# compose name of output file
$file_out = $file_in;
$file_out =~ s#^.*/##g;
$file_out =~ s/\.conf$/\.c/;
$file_out = "t_$file_out";

# name of log files
$file_testlog = $file_out;
$file_testlog =~ s/\.c$/_test\.log/;
$file_unuranlog = $file_out;
$file_unuranlog =~ s/\.c$/_unuran\.log/;

#get name of method 
$method = $file_in;
$method =~ s#^.*/##g;
$method =~ s/\.conf$//;
$method =~ tr/[A-Z]/[a-z]/;
$METHOD = $method;
$METHOD =~ tr/[a-z]/[A-Z]/;

#open files ...
open (IN,"$file_in")    or die "Cannot open file $file_in for reading";
open (OUT,">$file_out") or die "Cannot open file $file_out for writing";

# write out put header ...
print OUT "/*\n\tfile automatically generated by $name_program\n\t";
print OUT scalar localtime;
print OUT "\n*/\n\n";

############################################################
#                                                          #
#  scan main section                                       #
#                                                          #
############################################################

# data we want ...
undef $gen_type;
undef $distr_type;
undef $urng;
undef $C_header_aux;

my $section = "main";
undef my $next_section;

# search for begin of [main] section ...
$_ = "";
$_ = <IN> until /^\[main/;

# skip section marker
$_ = <IN> if /^\[main\]/;

# scan section ...
while (1) {

    # search for begin of next (sub) section ...
    $_ = <IN> until /^\[/;

    # check (sub) section name ...
    unless (/^\[($section)/) {
	die "wrong subsection" if /-/;
	# next section ...
	/\[(.*)\]/;
	$next_section = $1;
	last;
    }

    # get subsection name ...
    die "wrong section" unless /^\[$section\s+\-\s+(.*):/;
    my $subsection = $1;

    # search for closing ] ...
    $_ = <IN> until /\]/;
    $_ = <IN>;

    # scan subsection ...
    while (1) {
	if ( $subsection =~ /data/ ) {
	    #read data ...
	    if (/^\s*type\s*:\s*(\w+)/)          { $gen_type = $1; }
	    if (/^\s*distributions\s*:\s*(.+)$/) { $distr_type = $1; }
	    if (/^\s*urng\s*:\s*(.+)[\s\n]/)     { $urng = $1; }
	}
	elsif ( $subsection =~ /header/ ) {
	    # add verbatim to C header (except conf comments) ...
	    $C_header_aux .= $_ unless /^\#/; 
	}
	else {
	    die "Unknown subsection in [main]";
	}
	# next line ...
	$_ = <IN>;
	last if /^\[/;       # start of next (sub) section
    }
}

# check data ...
die "Data missing" unless (defined $gen_type and
			   defined $distr_type and 
			   defined $urng);

# which distributions ...
my @distr_lines = split /,/, $distr_type;
$test_distribution_type = "1";
foreach (@distr_lines) {
    $test_distribution_type .= " && (list_of_distr[n]. $_)";
}

############################################################
#                                                          #
#  C header and main()                                     #
#                                                          #
############################################################

# write ...
print_C_prototypes();

print OUT <<EOM;

/*---------------------------------------------------------------------------*/

int main()
{ 
	/* open log file for unuran and set output stream for unuran messages */
	UNURANLOG = fopen( "$file_unuranlog","w" );
	abort_if_NULL( -1, UNURANLOG );
	unur_set_stream( UNURANLOG );

	/* open log file for testing */
	TESTLOG = fopen( "$file_testlog","w" );
	abort_if_NULL( -1, TESTLOG );

	/* write header into log file */
  	{
		time_t started;  
		fprintf(TESTLOG,"\\nUNURAN - Universal Non-Uniform RANdom number generator\\n\\n");
		if (time( \&started ) != -1)
			fprintf(TESTLOG,"%s",ctime(\&started));
		fprintf(TESTLOG,"\\n====================================================\\n\\n");
	}

	/* set uniform random number generator */
	urng = prng_new("$urng");
	unur_set_default_urng(urng);

	/* set default debugging flag */
	unur_set_default_debug(UNUR_DEBUG_ALL);

	/* start test */
	printf("$method: ");

	/* run tests */
	test_new();
	test_set();
	test_chg();
	test_init();
	test_sample();
	test_reinit();
	test_validate();

	/* test finished */
	printf("\\n");  fflush(stdout);

	/* close log files */
	fprintf(TESTLOG,"\\n====================================================\\n\\n");
	if (test_ok)
		fprintf(TESTLOG,"All tests PASSED.\\n");
	else
		fprintf(TESTLOG,"Test(s) FAILED.\\n");

	fclose(UNURANLOG);
	fclose(TESTLOG);

	/* exit */
	exit( (test_ok) ? 0 : -1 );

} /* end of main */

EOM

############################################################
#                                                          #
#  scan all section until [verbatim]                       #
#                                                          #
############################################################

	$section = $next_section;

    until ($section =~ /verbatim/) {
	$next_section = scan_section($section);
	$section = $next_section;
    }

############################################################
#                                                          #
#  verbatim                                                #
#                                                          #
############################################################

# scan section ...
while (<IN>) {
    next if /^\#/;  # comment line
    s/\\#/#/g;
    print OUT;
}

print_C_routines();

############################################################
#                                                          #
#  end                                                     #
#                                                          #
############################################################

print OUT <<EOM;
/*---------------------------------------------------------------------------*/
#else
/*---------------------------------------------------------------------------*/
int main() { exit(77); } /* ignore test */
/*---------------------------------------------------------------------------*/
#endif  /* T_$METHOD */
/*---------------------------------------------------------------------------*/
EOM

############################################################

# close files ...
close(IN);
close(OUT);

############################################################

exit 0;

############################################################

############################################################
############################################################
############################################################
############################################################

############################################################
#                                                          #
#  subroutine: scan section                                #
#                                                          #
############################################################

sub scan_section {
    my $section = $_[0];   # name of section
    my $next_section;

    print OUT <<EOM;
/*---------------------------------------------------------------------------*/

void test_$section (void)
{
	/* start test */
	printf("[$section "); fflush(stdout);
	fprintf(TESTLOG,"\\n[$section]\\n");

	/* reset counter */
	n_tests_failed = 0;
  
EOM

    # search for begin of next (sub) section ...
    $_ = <IN> until /^\[/;
	
    # skip section marker
    $_ = <IN> if /^\[$section\]/;

    # scan section ...
    while (1) {

	# search for begin of next (sub) section ...
	$_ = <IN> until /^\[/;

	# check (sub) section name ...
	unless (/^\[($section)/) {
	    die "wrong subsection" if /-/;
	    # next section ...
	    /\[(.*)\]/;
	    $next_section = $1;
	    last;
	}

	# skip section marker
	next if /^\[$section\]/;

	# get subsection name ...
	die "wrong section" unless /^\[$section\s+\-\s+(.*):/;
	print OUT "/* $1 */\n";

	# clear variables ...
	$line = "";
	$subsection_closing = "";

	unless ( /\]\s*$/ ) {
	    while (<IN>) { 
		next if /^\#/;  # comment line
		# read until next empty line
		$line .= $_;
		last unless /[^\s]+/;
	    }

	    # there should be a closing ] ...
	    die "closing ] missing" unless $line =~ /\]\s*$/;
	

	    # remove this bracket ...
	    $line =~ s/\]\s*$/\n/;
	
	    # add declarations for variables distr, par and gen ...
	    # (and free these at the end of the subsection)
	    if ($line =~ /\s+gen\s+=/) { 
		$line = "UNUR_GEN   *gen = NULL\;\n".$line;
		$subsection_closing .= "unur_free(gen)\;\n";
	    }
	    if ($line =~ /\s+par\s+=/) {
		$line = "UNUR_PAR   *par = NULL\;\n".$line; 
	    }
	    if ($line =~ /\s+distr\s+=/) {
		$line = "UNUR_DISTR *distr = NULL\;\n".$line; 
		$subsection_closing .= "unur_distr_free(distr)\;\n";
	    }
	
	    # lines indicated with "<-- ! NULL" must not produce a NULL pointer 
	    $line =~ s/^(.*)=(.*)<--\s+!\s*NULL\s*\n/$1=$2\nabort_if_NULL\($INPUT_LINE_NUMBER, $1\)\;\n/mg;

	}
	else {
	    $_ = <IN>;
	}

	# print subsection header ...
	print OUT "{\n$line";

	# scan subsection body ...
	while (1) {
	    # search for non-empty line ...
	    $_ = <IN> until /\w+/;

	    # scan till next empty line of opening [ ...
	    my $line = "";
	    while (1) {
		if ( /^\#/ ) {
		    # comment line
		    $_ = <IN>;		# next line ...
		    next;
		}
		last unless /\w+/;   # empty line
		last if /^\[/;       # start of next (sub) section
		
		# convert line starting with ~ ...
		s/~/unur_$method\_$section/ if /^~/;

		# append line ...
		$line .= $_;

		# next line ...
		$_ = <IN>;
	    }
	    last if /^\[/;       # start of next (sub) section

	    # analyze string ...
	    my ($code,$test_command,$errno) = split /-->/, $line;

	    # is there any test ?
	    unless ($test_command) {
		print OUT $code if defined $code;
		next;
	    }
	    
	    # split into lines again ...
	    my @lines = split /\n/, $code;

	    # get last C command ...
	    undef my $last_C_line;
	    while ( $last_C_line = pop @lines ) {
		last if $last_C_line =~ /\w+/;
		last if !defined $last_C_line;
	    }
	    $last_C_line =~ s/;\s*$// if defined $last_C_line;

	    # print ...
	    print OUT "\nunur_errno = 0\;\n";

	    # C lines ...
	    foreach (@lines) {
		print OUT $_,"\n";
	    }

	    # test ...
	    print_test_command( $test_command, $last_C_line );

	    # error code ...
	    $errno =~ s/[\s\n]+//g if defined $errno;
	    print OUT "check_errorcode( $INPUT_LINE_NUMBER, $errno )\;\n" if $errno;

	}

	# close subsection ...
	print OUT $subsection_closing,"}\n\n";
    }

  # print section closing ...
  print OUT <<EOM;

	/* test finished */
	test_ok &= (n_tests_failed) ? 0 : 1;
	(n_tests_failed) ? printf("--> failed] ") : printf("--> ok] ");

} /* end of test_$section() */

EOM

    # return name of next section ...
    return $next_section;
} # end of scan_section()

############################################################
#                                                          #
#  subroutine: print test command                          #
#                                                          #
############################################################

@run_validate_chi2_commands = {};

$run_validate_chi2_done = 0;

sub print_test_command {
    my $test_command = $_[0];
    my $last_C_line = $_[1];

  SWITCH: {
      if ($test_command =~ /^\s*expected_NULL\s*/ or 
	  $test_command =~ /^\s*expected_setfailed\s*/ or 
	  $test_command =~ /^\s*expected_reinit\s*/ or
	  $test_command =~ /^\s*expected_no_reinit\s*/) {
	  $test_command =~ s/\s+//g;
	  print OUT "check_$test_command\( $INPUT_LINE_NUMBER, ($last_C_line) )\;\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*compare_double_sequence_par\s*$/ or
	  $test_command =~ /^\s*compare_double_sequence_par_start\s*$/ or
	  $test_command =~ /^\s*compare_int_sequence_par\s*$/ or
	  $test_command =~ /^\s*compare_int_sequence_par_start\s*$/ ) {
	  $test_command =~ s/\s+//g;
	  print OUT "$last_C_line\;\n";
	  print OUT "$test_command\( $INPUT_LINE_NUMBER, par, COMPARE_SAMPLE_SIZE );\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*compare_double_sequence_urng_start\s*$/ ) {
	  $test_command =~ s/\s+//g;
	  print OUT "$last_C_line\;\n";
	  print OUT "$test_command\( $INPUT_LINE_NUMBER, urng, COMPARE_SAMPLE_SIZE );\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*run_verify_generator\s*$/) {
	  print OUT "$last_C_line\;\n";
	  print OUT "$test_command( $INPUT_LINE_NUMBER, par );\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*run_validate_chi2\s*\{(.*)/) {
	  unless ($run_validate_chi2_done) {
	      # we only print this command once !
	      print OUT "run_validate_chi2( $INPUT_LINE_NUMBER );\n";
	      $run_validate_chi2_done = 1;
	  }
	  # append tests to list ...
	  split /[\{\}]/, $test_command;
	  push @run_validate_chi2_commands, $_[1];
	  last SWITCH;
      }

      # otherwise
      die "Unknown test command: \"$test_command\"";
  }

} # end print_test_command() 
		

############################################################
#                                                          #
#  subroutine: print common C functions                    #
#                                                          #
############################################################

sub print_C_prototypes {

    print OUT <<EOM;
/*****************************************************************************
 *                                                                           *
 *          UNURAN -- Universal Non-Uniform Random number generator          *
 *                                                                           *
 *****************************************************************************/
    
/**
 ** Tests for $METHOD
 **/
    
/*---------------------------------------------------------------------------*/
#include "testunuran.h"
/*---------------------------------------------------------------------------*/
#ifdef T_$METHOD
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* global variables                                                          */

static struct prng *urng;           /* uniform random number generator       */

static FILE *TESTLOG;               /* test log file                         */
static FILE *UNURANLOG;             /* unuran log file                       */

static int test_ok = TRUE;          /* all tests ok (boolean)                */
static int n_tests_failed;          /* number of failed tests                */

static struct list_distr *list_of_distr = NULL;  /* list of distributions    */
static int n_distr = 0;             /* number of distributions in list       */

static double *list_pvals = NULL; /* list of collected p-values              */
static int size_pvals = 0;        /* size of list                            */
static int n_pvals = 0;           /* number of collected p-values            */

/*---------------------------------------------------------------------------*/

void test_new( void );
void test_set( void );
void test_chg( void );
void test_init( void );
void test_reinit( void );
void test_sample( void );
void test_validate( void );

void abort_if_NULL( int line, void *ptr );
void check_errorcode( int line, unsigned errno );
void check_expected_NULL( int line, void *ptr );
void check_expected_setfailed( int line, int ok );
void check_expected_reinit( int line, int ok );
void check_expected_no_reinit( int line, int ok );
void compare_double_sequence_par( int line, UNUR_PAR *par, int sample_size );
void compare_double_sequence_par_start( int line, UNUR_PAR *par, int sample_size );
void compare_double_sequence_urng_start( int line, struct prng *prng, int sample_size );
void compare_int_sequence_par( int line, UNUR_PAR *par, int sample_size );
void compare_int_sequence_par_start( int line, UNUR_PAR *par, int sample_size );
void run_verify_generator( int line, UNUR_PAR *par );
void run_validate_chi2( int line );
void run_cont_chi2( int line, UNUR_PAR *par, UNUR_DISTR *distr );
void run_level2( int line, double *pvals, int n_pvals );
void print_distr_name( UNUR_DISTR *distr, const char *genid );
void print_pval( double pval, int trial );
void check_pval( int line, UNUR_GEN *gen, double pval, int trial );

/*---------------------------------------------------------------------------*/

$C_header_aux

EOM

} # end of print_C_prototypes()

############################################################

sub print_C_routines {

    print OUT <<EOM;

/*---------------------------------------------------------------------------*/
/* check for invalid NULL pointer, that should not happen in this program */

void abort_if_NULL( int line, void *ptr )
{
	if (ptr) return; /* o.k. */

	/* 
	   There must not be a NULL pointer.
	   Since we do not expect a NULL pointer something serious has
	   happend. So it is better to abort the tests.
	*/
	fprintf(TESTLOG,"line %4d: Unexpected NULL pointer. Panik --> Abort tests!!\\n\\n",line);
	printf(" Panik --> Tests aborted\\n"); fflush(stdout);

	test_ok = FALSE;
  
	/* test finished */
	printf("\\n");  fflush(stdout);

	/* close log files and exit */
	fclose(TESTLOG);
	fclose(UNURANLOG);
	exit(-1);
} /* abort_if_NULL() */

/*---------------------------------------------------------------------------*/
/* compare error code */

void check_errorcode( int line, unsigned errno )
{
	fprintf(TESTLOG,"line %4d: Error code ...\\t\\t",line);
	if (unur_errno != errno) {
		++n_tests_failed;
		fprintf(TESTLOG," Failed");
		fprintf(TESTLOG," (observed = %#x, expected = %#x)\\n",unur_errno,errno);
	}
	else
		fprintf(TESTLOG," ok\\n");
} /* end of check_errorcode() */

/*---------------------------------------------------------------------------*/
/* check for expected NULL pointer */

void check_expected_NULL( int line, void *ptr )
{
	fprintf(TESTLOG,"line %4d: NULL pointer expected ...\\t",line);
	if (ptr != NULL) { 
		++n_tests_failed;
		fprintf(TESTLOG," Failed\\n");
	}
	else
		fprintf(TESTLOG," ok\\n");
} /* end of check_expected_NULL() */

/*---------------------------------------------------------------------------*/
/* check for "set failed" */

void check_expected_setfailed( int line, int ok )
{
	fprintf(TESTLOG,"line %4d: `failed' expected ...\\t",line);
	if (ok) {
		++n_tests_failed;
		fprintf(TESTLOG," Failed\\n");
	}
	else
		fprintf(TESTLOG," ok\\n");
} /* end of check_expected_setfailed() */

/*---------------------------------------------------------------------------*/
/* check for reinit */

void check_expected_reinit( int line, int ok )
{
	fprintf(TESTLOG,"line %4d: reinit ...\\t\\t\\t",line);
	if (!ok) {
		++n_tests_failed;
		fprintf(TESTLOG," Failed\\n");
	}
	else
		fprintf(TESTLOG," ok\\n");
} /* end of check_expected_reinit() */

/*---------------------------------------------------------------------------*/
/* check for non existing reinit */

void check_expected_no_reinit( int line, int ok )
{
	fprintf(TESTLOG,"line %4d: no reinit ...\\t\\t",line);
	if (ok) {
		++n_tests_failed;
		fprintf(TESTLOG," Failed\\n");
	}
	else
		fprintf(TESTLOG," ok\\n");
} /* end of check_expected_no_reinit() */

/*---------------------------------------------------------------------------*/
/* compare double sequences generated by generator */

#define double_not_equal(a,b) \\
	( ((a) > 0. && ((a) > (1.+DBL_EPSILON) * (b) || \\
			(a) < (1.-DBL_EPSILON) * (b)) ) || \\
	  ((a) < 0. && ((a) < (1.+DBL_EPSILON) * (b) || \\
			(a) > (1.-DBL_EPSILON) * (b)) ) )

static double *double_sequence_A = NULL;

void compare_double_sequence_par_start( int line, UNUR_PAR *par, int sample_size )
{
	UNUR_GEN *gen;
	int i;

	if (double_sequence_A == NULL) {
		double_sequence_A = malloc( sample_size * sizeof(double) );
		abort_if_NULL(-1, double_sequence_A);
	}

	/* generate sequence */
	prng_reset(urng);
	gen = unur_init( par ); abort_if_NULL(line,gen);

	for (i=0; i<sample_size; i++)
		double_sequence_A[i] = unur_sample_cont(gen);

	unur_free(gen); 

} /* end of compare_double_sequence_par_start() */


void compare_double_sequence_urng_start( int line, struct prng *prng, int sample_size )
{
	int i;

	if (double_sequence_A == NULL) {
		double_sequence_A = malloc( sample_size * sizeof(double) );
		abort_if_NULL(-1, double_sequence_A);
	}

	/* generate sequence */
	prng_reset(prng);
	for (i=0; i<sample_size; i++)
		double_sequence_A[i] = prng_get_next(prng);

} /* end of compare_double_sequence_urng() */


void compare_double_sequence_par( int line, UNUR_PAR *par, int sample_size )
{
	UNUR_GEN *gen;
	int i;
	int ok = TRUE;
	double x;

	/* init generator */
	prng_reset(urng);
	gen = unur_init( par ); abort_if_NULL(line,gen);

	/* compare sequence */
	for (i=0; i<sample_size; i++) {
		x = unur_sample_cont(gen);	
		if (double_not_equal(double_sequence_A[i], x)) {
			ok = FALSE;
			break;
		}
	}

	/* free generator */
	unur_free(gen); 

	/* print result */
	fprintf(TESTLOG,"line %4d: random seqences ...\\t\\t",line);
	if (!ok) {
		++n_tests_failed;
		fprintf(TESTLOG," Failed\\n");
	}
	else
	fprintf(TESTLOG," ok\\n");

} /* end of compare_double_sequence_par() */

#undef double_not_equal(a,b)
	
/*---------------------------------------------------------------------------*/
/* compare int sequences generated by generator */

static int *int_sequence_A = NULL;

void compare_int_sequence_par_start( int line, UNUR_PAR *par, int sample_size )
{
	UNUR_GEN *gen;
	int i;

	if (int_sequence_A == NULL) {
		int_sequence_A = malloc( sample_size * sizeof(int) );
		abort_if_NULL(-1, int_sequence_A);
	}

	/* generate sequence */
	prng_reset(urng);
	gen = unur_init( par ); abort_if_NULL(line,gen);

	for (i=0; i<sample_size; i++)
		int_sequence_A[i] = unur_sample_discr(gen);

	unur_free(gen); 

} /* end of compare_int_sequence_par_start() */


void compare_int_sequence_par( int line, UNUR_PAR *par, int sample_size )
{
	UNUR_GEN *gen;
	int i;
	int ok = TRUE;

	/* init generator */
	prng_reset(urng);
	gen = unur_init( par ); abort_if_NULL(line,gen);

	/* compare sequence */
	for (i=0; i<sample_size; i++)
		if (int_sequence_A[i] != unur_sample_discr(gen)) {
			ok = FALSE;
			break;
		}

	/* free generator */
	unur_free(gen); 

	/* print result */
	fprintf(TESTLOG,"line %4d: random seqences ...\\t\\t",line);
	if (!ok) {
		++n_tests_failed;
		fprintf(TESTLOG," Failed\\n");
	}
	else
	fprintf(TESTLOG," ok\\n");

} /* end of compare_int_sequence_par() */
	
/*---------------------------------------------------------------------------*/
/* check for reinit */

void run_verify_generator( int line, UNUR_PAR *par )
{
	UNUR_GEN *gen;
	int i;

	/* switch to verifying mode */
	unur_$method\_set_verify(par,1);

	/* initialize generator */
	gen = unur_init( par ); abort_if_NULL(line, gen);

	/* run generator */
	for (i=0; i<VIOLATE_SAMPLE_SIZE; i++)
		unur_sample_cont(gen);

	/* destroy generator */
	unur_free(gen); 

} /* end of run_verify_generator() */

/*---------------------------------------------------------------------------*/
/* run chi2 test */

void run_validate_chi2( int line )
{
	UNUR_DISTR *distr;
	const char *distr_name;
	const char *last_distr_name = "";
	UNUR_PAR *par;
	int n;

	/* we need a list of distributions */
	if (list_of_distr == NULL)
		 n_distr = make_list_of_distributions( &list_of_distr );

	/* run chi^2 tests on test distributions */
	for (n=0; n<n_distr; n++) {

		/* test type of distribution */
		if( !($test_distribution_type) )
			/* we cannot use this method for this distribution */
			continue;

		/* get pointer to distribution */
		distr = list_of_distr[n].distr;

		/* get name of distribution */
		distr_name = unur_distr_get_name(distr);

		if (strcmp(distr_name,last_distr_name) ) {
		/* different distributions */
			last_distr_name = distr_name;
			printf(" %s",distr_name); fflush(stdout);
		}

		/* run tests */
EOM
    foreach (@run_validate_chi2_commands) {
	s/[\s\n]+/ /g;
	print OUT <<EOM;
		{
			$_
			run_$gen_type\_chi2( $INPUT_LINE_NUMBER, par, distr ); 
		}
EOM
    }
    print OUT <<EOM;
	}
	/* run level 2 test on collected p-values */
	run_level2($INPUT_LINE_NUMBER, list_pvals, n_pvals);

} /* end of run_validate_chi2() */

/*...........................................................................*/

void run_cont_chi2( int line, UNUR_PAR *par, UNUR_DISTR *distr )
{
	UNUR_GEN *gen;
	double pval;
	int i;

	gen = unur_init(par);
	if (gen==NULL) {
		/* this must not happen */
		++n_tests_failed;
		fprintf(TESTLOG,"line %4d: pval =     Initialization failed\\t\\t",line);
		print_distr_name( distr,"");
		fprintf(TESTLOG,"\\n");
		printf("0");
		return;
	}

	/* run chi^2 test */
	for (i=1; i<=2; i++) {

		/* we run the test twice when it fails the first time */
		pval = unur_test_chi2( gen, CHI_TEST_INTERVALS, 0, 20, 0);
		check_pval(line,gen,pval,i);

		/* store p-value */
		if (n_pvals >= size_pvals) {
			/* no space left in list: enlarge with 100 entries */
			size_pvals += 100;
			list_pvals = realloc( list_pvals, size_pvals * sizeof(double) );
		}
		/* append to list */
		list_pvals[n_pvals++] = pval;

		if (pval >= PVAL_LIMIT || pval < 0.) 
		/* test succeeded or not performed */
			break; 
	}

	unur_free(gen);

} /* end of run_cont_chi2() */

/*---------------------------------------------------------------------------*/
/* run level 2 test on collected p-values */

void run_level2( int line, double *pvals, int n_pvals )
{
	int i;
	int *classes;
	int n_classes;
	double pval2;

	if (pvals==NULL)
		/* nothing to do */
		return;

	/* number classes */
	n_classes = (int) (sqrt(n_pvals)+0.5);
	if (n_pvals/n_classes < 6)
		/* classes would have too few entries */
		n_classes = n_pvals / 6;

	/* allocate memory for classes */
	classes = calloc( n_classes+1, sizeof(int) );

	/* count bins */
	for (i=0; i<n_pvals; i++)
		++(classes[ (int)(pvals[i] * n_classes) ]);

	/* run test */
	pval2 = _unur_test_chi2test( NULL, classes, n_classes, 5, 0 );

	/* print result */
	printf(" Level-2-test(%d)",n_pvals);
	fprintf(TESTLOG,"line %4d: ",__LINE__);
	print_pval(pval2,100);
	fprintf(TESTLOG,"\\tLevel 2 Test (n=%d) (not powerful)\\n",n_pvals);

	/* clear */
	free(classes);

} /* end of run_level2() */

/*---------------------------------------------------------------------------*/
/* print name of distribution */

void print_distr_name( UNUR_DISTR *distr, const char *genid )
{
	int i,n_fpar;
	double *fpar;

	fprintf(TESTLOG,"%s: %s ",genid,unur_distr_get_name(distr));

	if ( unur_distr_is_cont(distr) ) {
		n_fpar = unur_distr_cont_get_pdfparams( distr, &fpar );
		fprintf(TESTLOG,"(");
		if (n_fpar) {
			fprintf(TESTLOG,"%g",fpar[0]);
			for (i=1; i<n_fpar; i++)
				fprintf(TESTLOG,", %g",fpar[i]);
		}
		fprintf(TESTLOG,")");
	}

} /* end of print_distr_name() */

/*---------------------------------------------------------------------------*/
/* print p-value of statistical test */

void print_pval( double pval, int trial )
{
	int l;

	if (pval < 0.) {
	/* test has not been executed */
		fprintf(TESTLOG,"pval = (0)\\t      Not performed");
		printf(".");
		return;
	}

	fprintf(TESTLOG,"pval = %8.6f   ",pval);

	l = -(int) ((pval > 1e-6) ? (log(pval) / M_LN10) : 6.);

	switch (l) {
	case 0:
		fprintf(TESTLOG,"      "); break;
	case 1:
		fprintf(TESTLOG,".     "); break;
	case 2:
		fprintf(TESTLOG,"**    "); break;
	case 3:
		fprintf(TESTLOG,"XXX   "); break;
	case 4:
		fprintf(TESTLOG,"XXXX  "); break;
	case 5:
		fprintf(TESTLOG,"XXXXX "); break;
	default:
		fprintf(TESTLOG,"######"); break;
	}
    
	if (pval < PVAL_LIMIT) {
		++n_tests_failed;
		if (trial > 1) {
			fprintf(TESTLOG,"\\t Failed");
			printf("X");
		}
		else {
			fprintf(TESTLOG,"\\t Try again");
			printf("?");
		}
	}
	else {
		fprintf(TESTLOG,"\\t ok");
		printf("+");
	}
	fflush(stdout);

} /* end of print_pval() */

/*---------------------------------------------------------------------------*/
/* check p-value of statistical test */

void check_pval( int line, UNUR_GEN *gen, double pval, int trial )
{
	fprintf(TESTLOG,"line %4d: ",line);
	print_pval(pval,trial);

	/* print distribution name */
	fprintf(TESTLOG,"\\t");
	print_distr_name( unur_get_distr(gen), unur_get_genid(gen) );
	fprintf(TESTLOG,"\\n");

} /* end of check_pval() */
  
EOM

} # end of print_C_routines()
