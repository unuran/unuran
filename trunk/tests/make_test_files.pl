#!/usr/bin/perl

$| =1;

############################################################
# $Id$

sub usage {
    my $progname = $0;
    $progname =~ s#^.*/##g;

    print STDERR <<EOM;
usage: $progname <test.conf> 
      
Scans <test.conf> and generates a C file with test routines.
File must have suffix "conf".

EOM

    exit;
}

############################################################

use English;

############################################################

$unuran_h_file = "../src/unuran.h";

#############################################################

############################################################
#                                                          #
#  main                                                    #
#                                                          #
############################################################

# get file names

# program name ...
$name_program = $0;
$name_program =~ s#^.*/##g;

# read in input file name from argument list ...
$file_in = shift;
(usage and die) unless $file_in;

#check suffix
(usage and die) unless ($file_in =~ /\.conf$/);

# compose name of output file
$file_out = $file_in;
$file_out =~ s#^.*/##g;
$file_out =~ s/\.conf$/\.c/;
$file_out = "t_$file_out";

# name of log files
$file_testlog = $file_out;
$file_testlog =~ s/\.c$/_test\.log/;
$file_unuranlog = $file_out;
$file_unuranlog =~ s/\.c$/_unuran\.log/;

#get name of method 
$method = $file_in;
$method =~ s#^.*/##g;
$method =~ s/\.conf$//;
$method =~ tr/[A-Z]/[a-z]/;
$METHOD = $method;
$METHOD =~ tr/[a-z]/[A-Z]/;

#open files ...
open (IN,"$file_in")    or die "Cannot open file $file_in for reading";
open (OUT,">$file_out") or die "Cannot open file $file_out for writing";

# write out put header ...
print OUT "/*\n\tfile automatically generated by $name_program\n\t";
print OUT scalar localtime;
print OUT "\n*/\n\n";

############################################################
#                                                          #
#  scan main section                                       #
#                                                          #
############################################################

# data we want ...
undef $gen_type;
undef $distr_type;
undef $urng;
undef $C_header_aux;

my $section = "main";
undef my $next_section;

# search for begin of [main] section ...
$_ = "";
$_ = <IN> until /^\[main/;

# skip section marker
$_ = <IN> if /^\[main\]/;

# scan section ...
while (1) {

    # search for begin of next (sub) section ...
    $_ = <IN> until /^\[/;

    # check (sub) section name ...
    unless (/^\[($section)/) {
	die "wrong subsection" if /-/;
	# next section ...
	/\[(.*)\]/;
	$next_section = $1;
	last;
    }

    # get subsection name ...
    die "wrong section" unless /^\[$section\s+\-\s+(.*):/;
    my $subsection = $1;

    # search for closing ] ...
    $_ = <IN> until /\]/;
    $_ = <IN>;

    # scan subsection ...
    while (1) {
	if ( $subsection =~ /data/ ) {
	    #read data ...
	    if (/^\s*type\s*:\s*(\w+)/)          { $gen_type = $1; }
	    if (/^\s*distributions\s*:\s*(.+)$/) { $distr_type = $1; }
	    if (/^\s*urng\s*:\s*(.+)[\s\n]/)     { $urng = $1; }
	}
	elsif ( $subsection =~ /header/ ) {
	    # add verbatim to C header (except conf comments) ...
	    $C_header_aux .= $_ unless /^\#/; 
	}
	else {
	    die "Unknown subsection in [main]";
	}
	# next line ...
	$_ = <IN>;
	last if /^\[/;       # start of next (sub) section
    }
}

# transform \# --> #
$C_header_aux =~ s/\\#/#/g;

# check data ...
die "Data missing" unless (defined $gen_type and
			   defined $distr_type and 
			   defined $urng);

# which distributions ...
my @distr_lines = split /,/, $distr_type;
$test_distribution_type = "1";
foreach (@distr_lines) {
    $test_distribution_type .= " && (list_of_distr[n]. $_)";
}

############################################################
#                                                          #
#  C header and main()                                     #
#                                                          #
############################################################

# write ...
print_C_prototypes();

print OUT <<EOM;

/*---------------------------------------------------------------------------*/

int main()
{ 
	/* open log file for unuran and set output stream for unuran messages */
	UNURANLOG = fopen( "$file_unuranlog","w" );
	abort_if_NULL( stderr,-1, UNURANLOG );
	unur_set_stream( UNURANLOG );

	/* open log file for testing */
	TESTLOG = fopen( "$file_testlog","w" );
	abort_if_NULL( stderr,-1, TESTLOG );

	/* write header into log file */
  	{
		time_t started;  
		fprintf(TESTLOG,"\\nUNURAN - Universal Non-Uniform RANdom number generator\\n\\n");
		if (time( \&started ) != -1)
			fprintf(TESTLOG,"%s",ctime(\&started));
		fprintf(TESTLOG,"\\n====================================================\\n\\n");
	}

	/* set uniform random number generator */
	urng = prng_new("$urng");
	unur_set_default_urng(urng);

	/* set default debugging flag */
	unur_set_default_debug(UNUR_DEBUG_ALL);

	/* start test */
	printf("$method: ");

	/* run tests */
	test_new();
	test_set();
	test_get();
	test_chg();
	test_init();
	test_sample();
	test_reinit();
	test_validate();

	/* test finished */
	printf("\\n");  fflush(stdout);

	/* close log files */
	fprintf(TESTLOG,"\\n====================================================\\n\\n");
	if (test_ok)
		fprintf(TESTLOG,"All tests PASSED.\\n");
	else
		fprintf(TESTLOG,"Test(s) FAILED.\\n");

	fclose(UNURANLOG);
	fclose(TESTLOG);

	/* exit */
	exit( (test_ok) ? 0 : -1 );

} /* end of main */

EOM

############################################################
#                                                          #
#  scan all section until [verbatim]                       #
#                                                          #
############################################################

    $section = $next_section;

until ($section =~ /verbatim/) {
    $next_section = scan_section($section);
    $section = $next_section;
}

############################################################
#                                                          #
#  verbatim                                                #
#                                                          #
############################################################

# scan section ...
while (<IN>) {
    next if /^\#/;  # comment line
    s/\\#/#/g;
    print OUT;
}

print_C_routines();

add_unur_set_verify_routine();

############################################################
#                                                          #
#  end                                                     #
#                                                          #
############################################################

print OUT <<EOM;
/*---------------------------------------------------------------------------*/
#else
/*---------------------------------------------------------------------------*/
int main() { exit(77); } /* ignore test */
/*---------------------------------------------------------------------------*/
#endif  /* T_$METHOD */
/*---------------------------------------------------------------------------*/
EOM

############################################################

# close files ...
close(IN);
close(OUT);

############################################################

exit 0;

############################################################

############################################################
############################################################
############################################################
############################################################

############################################################
#                                                          #
#  subroutine: scan section                                #
#                                                          #
############################################################

sub scan_section {
    my $section = $_[0];   # name of section
    my $next_section;

    print OUT <<EOM;
/*---------------------------------------------------------------------------*/

void test_$section (void)
{
	/* start test */
	printf("[$section "); fflush(stdout);
	fprintf(TESTLOG,"\\n[$section]\\n");

	/* reset counter */
	n_tests_failed = 0;
  
EOM

    # search for begin of next (sub) section ...
    $_ = <IN> until /^\[/;
	
    # skip section marker
    $_ = <IN> if /^\[$section\]/;

    # scan section ...
    while (1) {

	# search for begin of next (sub) section ...
	$_ = <IN> until /^\[/;

	# check (sub) section name ...
	unless (/^\[($section)/) {
	    die "wrong subsection" if /-/;
	    # next section ...
	    /\[(.*)\]/;
	    $next_section = $1;
	    last;
	}

	# skip section marker
	next if /^\[$section\]/;

	# get subsection name ...
	die "wrong section" unless /^\[$section\s+\-\s+(.*):/;
	print OUT "/* $1 */\n";

	# clear variables ...
	$line = "";
	$subsection_closing = "";

	unless ( /\]\s*$/ ) {
	    while (<IN>) { 
		next if /^\#/;  # comment line
		# read until next empty line
		$line .= $_;
		last unless /[^\s]+/;
	    }

            # transform \# --> #
	    $line =~ s/\\#/#/g;

	    # there should be a closing ] ...
	    die "closing ] missing" unless $line =~ /\]\s*$/;
	
	    # remove this bracket ...
	    $line =~ s/\]\s*$/\n/;
	
	    # add declarations for variables distr, par and gen ...
	    # (and free these at the end of the subsection)
	    if ($line =~ /\s+gen\s+=/) { 
		$line = "UNUR_GEN   *gen = NULL\;\n".$line;
		$subsection_closing .= "unur_free(gen)\;\n";
	    }
	    if ($line =~ /\s+par\s+=/) {
		$line = "UNUR_PAR   *par = NULL\;\n".$line; 
	    }
	    if ($line =~ /\s+distr\s+=/) {
		$line = "UNUR_DISTR *distr = NULL\;\n".$line; 
		$subsection_closing .= "unur_distr_free(distr)\;\n";
	    }
	
	    # lines indicated with "<-- ! NULL" must not produce a NULL pointer 
	    $line =~ s/^(.*)=(.*)<--\s+!\s*NULL\s*\n/$1=$2\nabort_if_NULL\(TESTLOG, $INPUT_LINE_NUMBER, $1\)\;\n/mg;

	}
	else {
	    $_ = <IN>;
	}

	# print subsection header ...
	print OUT "{\n$line";

	# scan subsection body ...
	while (1) {
	    # search for non-empty line ...
	    $_ = <IN> until /\w+/;

	    # scan till next empty line of opening [ ...
	    my $line = "";
	    while (1) {
		if ( /^\#/ ) {
		    # comment line
		    $_ = <IN>;		# next line ...
		    next;
		}
		last unless /\w+/;   # empty line
		last if /^\[/;       # start of next (sub) section
		
		# convert line starting with ~ ...
		s/~/unur_$method\_$section/ if /^~/;

		# append line ...
		$line .= $_;

		# next line ...
		$_ = <IN>;
	    }
	    last if /^\[/;       # start of next (sub) section

            # transform \# --> #
	    $line =~ s/\\#/#/g;

	    # analyze string ...
	    my ($code,$test_command,$errno) = split /-->/, $line;

	    # is there any test ?
	    unless ($test_command) {
		print OUT $code if defined $code;
		next;
	    }
	    
	    # split into lines again ...
	    my @lines = split /\n/, $code;

	    # get last C command ...
	    undef my $last_C_line;
	    while ( $last_C_line = pop @lines ) {
		last if $last_C_line =~ /\w+/;
		last if !defined $last_C_line;
	    }
	    $last_C_line =~ s/;\s*$// if defined $last_C_line;

	    # print ...
	    print OUT "\nunur_errno = 0\;\n";

	    # C lines ...
	    foreach (@lines) {
		print OUT $_,"\n";
	    }

	    # test ...
	    print_test_command( $test_command, $last_C_line );

	    # error code ...
	    $errno =~ s/[\s\n]+//g if defined $errno;
	    print OUT "n_tests_failed += check_errorcode( TESTLOG, $INPUT_LINE_NUMBER, $errno )\;\n" if $errno;

	}

	# close subsection ...
	print OUT $subsection_closing,"}\n\n";
    }

  # print section closing ...
  print OUT <<EOM;

	/* test finished */
	test_ok &= (n_tests_failed) ? 0 : 1;
	(n_tests_failed) ? printf("--> failed] ") : printf("--> ok] ");

} /* end of test_$section() */

EOM

    # return name of next section ...
    return $next_section;
} # end of scan_section()

############################################################
#                                                          #
#  subroutine: print test command                          #
#                                                          #
############################################################

@run_validate_chi2_commands = {};

$run_validate_chi2_done = 0;

sub print_test_command {
    my $test_command = $_[0];
    my $last_C_line = $_[1];

  SWITCH: {
      if ($test_command =~ /^\s*none\s*/ ) {
	  $test_command =~ s/\s+//g;
	  print OUT "$last_C_line\;\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*expected_NULL\s*/ or 
	  $test_command =~ /^\s*expected_setfailed\s*/ or 
	  $test_command =~ /^\s*expected_INFINITY\s*/ or 
	  $test_command =~ /^\s*expected_reinit\s*/ or
	  $test_command =~ /^\s*expected_no_reinit\s*/) {
	  $test_command =~ s/\s+//g;
	  print OUT "n_tests_failed += check_$test_command\( TESTLOG, $INPUT_LINE_NUMBER, ($last_C_line) )\;\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*compare_double_sequence_par\s*$/ or
	  $test_command =~ /^\s*compare_double_sequence_par_start\s*$/ or
	  $test_command =~ /^\s*compare_int_sequence_par\s*$/ or
	  $test_command =~ /^\s*compare_int_sequence_par_start\s*$/ ) {
	  $test_command =~ s/\s+//g;
	  print OUT "$last_C_line\;\n";
	  print OUT "n_tests_failed += $test_command\( TESTLOG, $INPUT_LINE_NUMBER, urng, par, COMPARE_SAMPLE_SIZE );\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*compare_double_sequence_urng_start\s*$/ ) {
	  $test_command =~ s/\s+//g;
	  print OUT "$last_C_line\;\n";
	  print OUT "$test_command\( TESTLOG, $INPUT_LINE_NUMBER, urng, COMPARE_SAMPLE_SIZE );\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*run_verify_generator\s*$/) {
	  print OUT "$last_C_line\;\n";
	  print OUT "$test_command( TESTLOG,$INPUT_LINE_NUMBER, par );\n";
	  last SWITCH;
      }
      if ($test_command =~ /^\s*run_validate_chi2\s*\{(.*)/) {
	  unless ($run_validate_chi2_done) {
	      # we only print this command once !
	      print OUT "run_validate_chi2( $INPUT_LINE_NUMBER );\n";
	      $run_validate_chi2_done = 1;
	  }
	  # append tests to list ...
	  split /[\{\}]/, $test_command;
	  push @run_validate_chi2_commands, $_[1];
	  last SWITCH;
      }

      # otherwise
      die "Unknown test command: \"$test_command\"";
  }

} # end print_test_command() 
		

############################################################
#                                                          #
#  subroutine: print common C functions                    #
#                                                          #
############################################################

sub print_C_prototypes {

    print OUT <<EOM;
/*****************************************************************************
 *                                                                           *
 *          UNURAN -- Universal Non-Uniform Random number generator          *
 *                                                                           *
 *****************************************************************************/
    
/**
 ** Tests for $METHOD
 **/
    
/*---------------------------------------------------------------------------*/
#include "testunuran.h"
/*---------------------------------------------------------------------------*/
#ifdef T_$METHOD
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* global variables                                                          */

static struct prng *urng;           /* uniform random number generator       */

static FILE *TESTLOG;               /* test log file                         */
static FILE *UNURANLOG;             /* unuran log file                       */

static int test_ok = TRUE;          /* all tests ok (boolean)                */
static int n_tests_failed;          /* number of failed tests                */

static struct list_distr *list_of_distr = NULL;  /* list of distributions    */
static int n_distr = 0;             /* number of distributions in list       */

static double *list_pvals = NULL; /* list of collected p-values              */
static int size_pvals = 0;        /* size of list                            */
static int n_pvals = 0;           /* number of collected p-values            */

/*---------------------------------------------------------------------------*/

void test_new( void );
void test_set( void );
void test_get( void );
void test_chg( void );
void test_init( void );
void test_reinit( void );
void test_sample( void );
void test_validate( void );

void run_verify_generator( FILE *LOG, int line, UNUR_PAR *par );
void run_validate_chi2( int line );

int unur_$method\_set_verify( UNUR_PAR *par, int );

/*---------------------------------------------------------------------------*/

$C_header_aux

EOM

} # end of print_C_prototypes()

############################################################

sub print_C_routines {

    print OUT <<EOM;


/*---------------------------------------------------------------------------*/
/* run generator in verifying mode */

void run_verify_generator( FILE *LOG, int line, UNUR_PAR *par )
{
	UNUR_GEN *gen;
	int i;

	/* switch to verifying mode */
	unur_$method\_set_verify(par,1);

	/* initialize generator */
	gen = unur_init( par ); abort_if_NULL(LOG, line, gen);

	/* run generator */
	for (i=0; i<VIOLATE_SAMPLE_SIZE; i++)
		unur_sample_cont(gen);

	/* destroy generator */
	unur_free(gen); 

} /* end of run_verify_generator() */

/*---------------------------------------------------------------------------*/
/* run chi2 test */

void run_validate_chi2( int line )
{
	UNUR_DISTR *distr;
	const char *distr_name;
	const char *last_distr_name = "";
	UNUR_PAR *par;
	int n;

	/* we need a list of distributions */
	if (list_of_distr == NULL)
		 n_distr = make_list_of_distributions( &list_of_distr );

	/* run chi^2 tests on test distributions */
	for (n=0; n<n_distr; n++) {

		/* test type of distribution */
		if( !($test_distribution_type) )
			/* we cannot use this method for this distribution */
			continue;

		/* get pointer to distribution */
		distr = list_of_distr[n].distr;

		/* get name of distribution */
		distr_name = unur_distr_get_name(distr);

		if (strcmp(distr_name,last_distr_name) ) {
		/* different distributions */
			last_distr_name = distr_name;
			printf(" %s",distr_name); fflush(stdout);
		}

		/* run tests */
EOM
    my $TYPE = ($gen_type =~ "cont") ? "CONTINUOUS" : "DISCRETE";
    foreach (@run_validate_chi2_commands) {
	s/[\s\n]+/ /g;
	print OUT <<EOM;
		{
			$_
			n_tests_failed += run_chi2( TESTLOG,$INPUT_LINE_NUMBER, $TYPE, par, distr, 
                                  &list_pvals, &size_pvals, &n_pvals );


		}
EOM
    }
    print OUT <<EOM;
	}
	/* run level 2 test on collected p-values */
	n_tests_failed += run_level2(TESTLOG, $INPUT_LINE_NUMBER, list_pvals, n_pvals);

	/* one test might fail */
	if (n_tests_failed == 1)
	    n_tests_failed = 0;

} /* end of run_validate_chi2() */

/*...........................................................................*/

  
EOM

} # end of print_C_routines()

############################################################

sub add_unur_set_verify_routine {
    my $verify = "unur_$method\_set_verify";
    undef my $have_found;

    open (H,"$unuran_h_file")    or die "Cannot open file $unuran_h_file for reading";
    while (<H>) {
	$have_found = 1 if /$verify/;
    }

    unless ($have_found) {
	print OUT "int $verify(UNUR_PAR *par, int verify) {return 0;}\n";
    }
}

############################################################
