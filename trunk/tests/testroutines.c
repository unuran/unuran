/*****************************************************************************
 *                                                                           *
 *          UNURAN -- Universal Non-Uniform Random number generator          *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 *  Common test routines                                                     *
 *                                                                           *
 *****************************************************************************/

/*---------------------------------------------------------------------------*/

#include "testunuran.h"

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* check for invalid NULL pointer, that should not happen in this program */

void abort_if_NULL( FILE *LOG, int line, void *ptr )
{
  if (ptr) return; /* o.k. */
  
  /* 
     There must not be a NULL pointer.
     Since we do not expect a NULL pointer something serious has
     happend. So it is better to abort the tests.
  */
  fprintf(LOG,"line %4d: Unexpected NULL pointer. Panik --> Abort tests!!\n\n",line);
  printf(" Panik --> Tests aborted\n"); fflush(stdout);
  
  /* test finished */
  printf("\n");  fflush(stdout);
  
  /* close log files and exit */
  fclose(LOG);
  exit(-1);
  
} /* abort_if_NULL() */

/*---------------------------------------------------------------------------*/
/* compare error code */

int check_errorcode( FILE *LOG, int line, unsigned errno )
{
  int failed = 0;

  fprintf(LOG,"line %4d: Error code ...\t\t",line);
  if (unur_errno != errno) {
    failed = 1;
    fprintf(LOG," Failed");
    fprintf(LOG," (observed = %#x, expected = %#x)\n",unur_errno,errno);
  }
  else
    fprintf(LOG," ok\n");

  return failed;

} /* end of check_errorcode() */

/*---------------------------------------------------------------------------*/
/* check for expected NULL pointer */

int check_expected_NULL( FILE *LOG, int line, void *ptr )
{
  int failed = 0;

  fprintf(LOG,"line %4d: NULL pointer expected ...\t",line);
  if (ptr != NULL) { 
    failed = 1;
    fprintf(LOG," Failed\n");
  }
  else
    fprintf(LOG," ok\n");

  return failed;

} /* end of check_expected_NULL() */

/*---------------------------------------------------------------------------*/
/* check for "set failed" */

int check_expected_setfailed( FILE *LOG, int line, int ok )
{
  int failed = 0;

  fprintf(LOG,"line %4d: `failed' expected ...\t",line);
  if (ok) {
    failed = 1;
    fprintf(LOG," Failed\n");
  }
  else
    fprintf(LOG," ok\n");

  return failed;

} /* end of check_expected_setfailed() */

/*---------------------------------------------------------------------------*/
/* check for INFINITY */

int check_expected_INFINITY( FILE *LOG, int line, double x )
{
  int failed = 0;

  fprintf(LOG,"line %4d: INFINITY expected ...\t",line);
  if (x < UNUR_INFINITY) {
    failed = 1;
    fprintf(LOG," Failed\n");
  }
  else
    fprintf(LOG," ok\n");

  return failed;

} /* end of check_expected_INFINITY() */

/*---------------------------------------------------------------------------*/
/* check for reinit */

int check_expected_reinit( FILE *LOG, int line, int ok )
{
  int failed = 0;

  fprintf(LOG,"line %4d: reinit ...\t\t\t",line);
  if (!ok) {
    failed = 1;
    fprintf(LOG," Failed\n");
  }
  else
    fprintf(LOG," ok\n");

  return failed;

} /* end of check_expected_reinit() */

/*---------------------------------------------------------------------------*/
/* check for non existing reinit */

int check_expected_no_reinit( FILE *LOG, int line, int ok )
{
  int failed = 0;

  fprintf(LOG,"line %4d: no reinit ...\t\t",line);
  if (ok) {
    failed = 1;
    fprintf(LOG," Failed\n");
  }
  else
    fprintf(LOG," ok\n");

  return failed;

} /* end of check_expected_no_reinit() */

/*---------------------------------------------------------------------------*/
/* compare double sequences generated by generator */

#define double_not_equal(a,b) \
	( ((a) > 0. && ((a) > (1.+DBL_EPSILON) * (b) || \
			(a) < (1.-DBL_EPSILON) * (b)) ) || \
	  ((a) < 0. && ((a) < (1.+DBL_EPSILON) * (b) || \
			(a) > (1.-DBL_EPSILON) * (b)) ) )

static double *double_sequence_A = NULL;

int compare_double_sequence_par_start( FILE *LOG, int line, struct prng *urng, UNUR_PAR *par, int sample_size )
{
  UNUR_GEN *gen;
  int i;

  if (double_sequence_A == NULL) {
    double_sequence_A = malloc( sample_size * sizeof(double) );
    abort_if_NULL(LOG,line, double_sequence_A);
  }

  /* generate sequence */
  prng_reset(urng);
  gen = unur_init( par ); abort_if_NULL(LOG,line,gen);
  
  for (i=0; i<sample_size; i++)
    double_sequence_A[i] = unur_sample_cont(gen);
  
  unur_free(gen); 

  /* there cannot be a failure */
  return 0;

} /* end of compare_double_sequence_par_start() */

/*...........................................................................*/

int compare_double_sequence_urng_start( FILE *LOG, int line, struct prng *urng, int sample_size )
{
  int i;
  
  if (double_sequence_A == NULL) {
    double_sequence_A = malloc( sample_size * sizeof(double) );
    abort_if_NULL(LOG, line, double_sequence_A);
  }

  /* generate sequence */
  prng_reset(urng);
  for (i=0; i<sample_size; i++)
    double_sequence_A[i] = prng_get_next(urng);

  /* there cannot be a failure */
  return 0;

} /* end of compare_double_sequence_urng() */

/*...........................................................................*/

int compare_double_sequence_par( FILE *LOG, int line, struct prng *urng, UNUR_PAR *par, int sample_size )
{
  UNUR_GEN *gen;
  int i;
  int ok = TRUE;
  double x;
  int failed = 0;

  /* init generator */
  prng_reset(urng);
  gen = unur_init( par ); abort_if_NULL(LOG, line,gen);
  
  /* compare sequence */
  for (i=0; i<sample_size; i++) {
    x = unur_sample_cont(gen);	
    if ( double_not_equal(double_sequence_A[i], x)) {
      ok = FALSE;
      break;
    }
  }

  /* free generator */
  unur_free(gen); 
  
  /* print result */
  fprintf(LOG,"line %4d: random seqences ...\t\t",line);
  if (!ok) {
    failed = 1;
    fprintf(LOG," Failed\n");
  }
  else
    fprintf(LOG," ok\n");
  
  return failed;

} /* end of compare_double_sequence_par() */

#undef double_not_equal(a,b)
	
/*---------------------------------------------------------------------------*/
/* compare int sequences generated by generator */

static int *int_sequence_A = NULL;

int compare_int_sequence_par_start( FILE *LOG, int line, struct prng *urng, UNUR_PAR *par, int sample_size )
{
  UNUR_GEN *gen;
  int i;

  if (int_sequence_A == NULL) {
    int_sequence_A = malloc( sample_size * sizeof(int) );
    abort_if_NULL(LOG, line, int_sequence_A);
  }
  
  /* generate sequence */
  prng_reset(urng);
  gen = unur_init( par ); abort_if_NULL(LOG, line,gen);

  for (i=0; i<sample_size; i++)
    int_sequence_A[i] = unur_sample_discr(gen);

  unur_free(gen); 

  /* there cannot be a failure */
  return 0;

} /* end of compare_int_sequence_par_start() */

/*...........................................................................*/

int compare_int_sequence_par( FILE *LOG, int line, struct prng *urng, UNUR_PAR *par, int sample_size )
{
  UNUR_GEN *gen;
  int i;
  int ok = TRUE;
  int failed = 0;

  /* init generator */
  prng_reset(urng);
  gen = unur_init( par ); abort_if_NULL(LOG, line,gen);
  
  /* compare sequence */
  for (i=0; i<sample_size; i++)
    if (int_sequence_A[i] != unur_sample_discr(gen)) {
      ok = FALSE;
      break;
    }
  
  /* free generator */
  unur_free(gen); 
  
  /* print result */
  fprintf(LOG,"line %4d: random seqences ...\t\t",line);
  if (!ok) {
    failed = 1;
    fprintf(LOG," Failed\n");
  }
  else
    fprintf(LOG," ok\n");
  
  return failed;

} /* end of compare_int_sequence_par() */

/*---------------------------------------------------------------------------*/
/* print name of distribution */

void print_distr_name( FILE *LOG, UNUR_DISTR *distr, const char *genid )
{
  int i,n_fpar;
  double *fpar;

  fprintf(LOG,"%s: %s ",genid,unur_distr_get_name(distr));

  if ( unur_distr_is_cont(distr) ) {
    n_fpar = unur_distr_cont_get_pdfparams( distr, &fpar );
    fprintf(LOG,"(");
    if (n_fpar) {
      fprintf(LOG,"%g",fpar[0]);
      for (i=1; i<n_fpar; i++)
	fprintf(LOG,", %g",fpar[i]);
    }
    fprintf(LOG,")");
  }

} /* end of print_distr_name() */

/*---------------------------------------------------------------------------*/
/* print p-value of statistical test */

int print_pval( FILE *LOG, double pval, int trial )
{
  int l;
  int failed = 0;

  if (pval < 0.) {
    /* test has not been executed */
    fprintf(LOG,"pval = (0)\t      Not performed");
    printf(".");
    return 0;
  }

  fprintf(LOG,"pval = %8.6f   ",pval);

  l = -(int) ((pval > 1e-6) ? (log(pval) / M_LN10) : 6.);

  switch (l) {
  case 0:
    fprintf(LOG,"      "); break;
  case 1:
    fprintf(LOG,".     "); break;
  case 2:
    fprintf(LOG,"**    "); break;
  case 3:
    fprintf(LOG,"XXX   "); break;
  case 4:
    fprintf(LOG,"XXXX  "); break;
  case 5:
    fprintf(LOG,"XXXXX "); break;
  default:
    fprintf(LOG,"######"); break;
  }
    
  if (pval < PVAL_LIMIT) {
    failed = 1;
    if (trial > 1) {
      fprintf(LOG,"\t Failed");
      printf("X");
    }
    else {
      fprintf(LOG,"\t Try again");
      printf("?");
    }
  }
  else {
    fprintf(LOG,"\t ok");
    printf("+");
  }
  fflush(stdout);

  return failed;
  
} /* end of print_pval() */

/*---------------------------------------------------------------------------*/
/* check p-value of statistical test */

int check_pval( FILE *LOG, int line, UNUR_GEN *gen, double pval, int trial )
{
  int failed = 0;

  fprintf(LOG,"line %4d: ",line);
  failed = print_pval(LOG,pval,trial);

  /* print distribution name */
  fprintf(LOG,"\t");
  print_distr_name( LOG,unur_get_distr(gen), unur_get_genid(gen) );
  fprintf(LOG,"\n");

  return failed;

} /* end of check_pval() */

/*---------------------------------------------------------------------------*/
/* run level 2 test on collected p-values */

int run_level2( FILE *LOG, int line, double *pvals, int n_pvals )
{
  int i;
  int *classes;
  int n_classes;
  double pval2;
  int failed = 0;

  if (pvals==NULL)
    /* nothing to do */
    return 0;

  /* number classes */
  n_classes = (int) (sqrt(n_pvals)+0.5);
  if (n_pvals/n_classes < 6)
    /* classes would have too few entries */
    n_classes = n_pvals / 6;
  
  /* allocate memory for classes */
  classes = malloc( (n_classes+1) * sizeof(int) );
  for (i=0; i<n_classes+1; i++)
    classes[i] = 0;
  
  /* count bins */
  for (i=0; i<n_pvals; i++)
    ++(classes[ (int)(pvals[i] * n_classes) ]);

  /* run test */
  pval2 = _unur_test_chi2test( NULL, classes, n_classes, 5, 0 );

  /* print result */
  printf(" Level-2-test(%d)",n_pvals);
  fprintf(LOG,"line %4d: ",line);
  failed = print_pval(LOG,pval2,100);
  fprintf(LOG,"\tLevel 2 Test (n=%d) (not powerful)\n",n_pvals);

  /* clear */
  free(classes);

  return failed;

} /* end of run_level2() */

/*---------------------------------------------------------------------------*/
/* run chi^2 tests */

int run_chi2( FILE *LOG, int line, int type, UNUR_PAR *par, UNUR_DISTR *distr,
	      double **list_pvals, int *size_pvals, int *n_pvals )
{
  UNUR_GEN *gen;
  double pval;
  int i;
  int failed = 0;

  /* set debugging flag */
/*    unur_set_debug(par,1); */

  gen = unur_init(par);
  if (gen==NULL) {
    /* this must not happen */
    fprintf(LOG,"line %4d: pval =     Initialization failed\t\t",line);
    print_distr_name( LOG,distr,"");
    fprintf(LOG,"\n");
    printf("0");
    return 0;
  }

  /* run chi^2 test */
  for (i=1; i<=2; i++) {

    /* we run the test twice when it fails the first time */
    switch (type) {
    case CONTINUOUS:
      pval = unur_test_chi2( gen, CHI_TEST_INTERVALS, 0, 20, 0);
      break;
    case DISCRETE:
      pval = unur_test_chi2( gen, CHI_TEST_INTERVALS, 100000, 20, 0);
      break;
    default:
      fprintf(stderr,"this should not happen\n");
      exit (-1);
    }

    failed += check_pval(LOG,line,gen,pval,i);

    /* store p-value */
    if (*n_pvals >= *size_pvals) {
      /* no space left in list: enlarge with 100 entries */
      *size_pvals += 100;
      *list_pvals = realloc( *list_pvals, *size_pvals * sizeof(double) );
    }
    /* append to list */
    (*list_pvals)[(*n_pvals)++] = pval;

    if (pval >= PVAL_LIMIT || pval < 0.) 
      /* test succeeded or not performed */
      break; 
  }

  unur_free(gen);

  return failed;

} /* end of run_chi2() */

/*---------------------------------------------------------------------------*/


